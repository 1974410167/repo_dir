-- MySQL dump 10.13  Distrib 5.7.33, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.33-0ubuntu0.18.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `auth_group`
--

DROP TABLE IF EXISTS `auth_group`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(150) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group`
--

LOCK TABLES `auth_group` WRITE;
/*!40000 ALTER TABLE `auth_group` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group_permissions`
--

DROP TABLE IF EXISTS `auth_group_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_group_permissions_group_id_permission_id_0cd325b0_uniq` (`group_id`,`permission_id`),
  KEY `auth_group_permissio_permission_id_84c5c92e_fk_auth_perm` (`permission_id`),
  CONSTRAINT `auth_group_permissio_permission_id_84c5c92e_fk_auth_perm` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`),
  CONSTRAINT `auth_group_permissions_group_id_b120cbf9_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group_permissions`
--

LOCK TABLES `auth_group_permissions` WRITE;
/*!40000 ALTER TABLE `auth_group_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_permission`
--

DROP TABLE IF EXISTS `auth_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `content_type_id` int(11) NOT NULL,
  `codename` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_permission_content_type_id_codename_01ab375a_uniq` (`content_type_id`,`codename`),
  CONSTRAINT `auth_permission_content_type_id_2f476e4b_fk_django_co` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_permission`
--

LOCK TABLES `auth_permission` WRITE;
/*!40000 ALTER TABLE `auth_permission` DISABLE KEYS */;
INSERT INTO `auth_permission` VALUES (1,'Can add log entry',1,'add_logentry'),(2,'Can change log entry',1,'change_logentry'),(3,'Can delete log entry',1,'delete_logentry'),(4,'Can view log entry',1,'view_logentry'),(5,'Can add permission',2,'add_permission'),(6,'Can change permission',2,'change_permission'),(7,'Can delete permission',2,'delete_permission'),(8,'Can view permission',2,'view_permission'),(9,'Can add group',3,'add_group'),(10,'Can change group',3,'change_group'),(11,'Can delete group',3,'delete_group'),(12,'Can view group',3,'view_group'),(13,'Can add user',4,'add_user'),(14,'Can change user',4,'change_user'),(15,'Can delete user',4,'delete_user'),(16,'Can view user',4,'view_user'),(17,'Can add content type',5,'add_contenttype'),(18,'Can change content type',5,'change_contenttype'),(19,'Can delete content type',5,'delete_contenttype'),(20,'Can view content type',5,'view_contenttype'),(21,'Can add session',6,'add_session'),(22,'Can change session',6,'change_session'),(23,'Can delete session',6,'delete_session'),(24,'Can view session',6,'view_session'),(25,'Can add 标签 ',7,'add_tag'),(26,'Can change 标签 ',7,'change_tag'),(27,'Can delete 标签 ',7,'delete_tag'),(28,'Can view 标签 ',7,'view_tag'),(29,'Can add 分类',8,'add_category'),(30,'Can change 分类',8,'change_category'),(31,'Can delete 分类',8,'delete_category'),(32,'Can view 分类',8,'view_category'),(33,'Can add 文章',9,'add_post'),(34,'Can change 文章',9,'change_post'),(35,'Can delete 文章',9,'delete_post'),(36,'Can view 文章',9,'view_post'),(37,'Can add 评论',10,'add_comment'),(38,'Can change 评论',10,'change_comment'),(39,'Can delete 评论',10,'delete_comment'),(40,'Can view 评论',10,'view_comment'),(41,'Can add 个性签名',11,'add_text_signature'),(42,'Can change 个性签名',11,'change_text_signature'),(43,'Can delete 个性签名',11,'delete_text_signature'),(44,'Can view 个性签名',11,'view_text_signature'),(45,'Can add 关于',12,'add_about_me'),(46,'Can change 关于',12,'change_about_me'),(47,'Can delete 关于',12,'delete_about_me'),(48,'Can view 关于',12,'view_about_me');
/*!40000 ALTER TABLE `auth_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user`
--

DROP TABLE IF EXISTS `auth_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `password` varchar(128) NOT NULL,
  `last_login` datetime(6) DEFAULT NULL,
  `is_superuser` tinyint(1) NOT NULL,
  `username` varchar(150) NOT NULL,
  `first_name` varchar(150) NOT NULL,
  `last_name` varchar(150) NOT NULL,
  `email` varchar(254) NOT NULL,
  `is_staff` tinyint(1) NOT NULL,
  `is_active` tinyint(1) NOT NULL,
  `date_joined` datetime(6) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user`
--

LOCK TABLES `auth_user` WRITE;
/*!40000 ALTER TABLE `auth_user` DISABLE KEYS */;
INSERT INTO `auth_user` VALUES (1,'pbkdf2_sha256$216000$Roa4ecDiEgyQ$02WfdBzFJ0Gtas9ZJYyterBlYXPmAzxw+lfXta9TbKM=','2023-10-25 17:19:29.425127',1,'ghyuan','','','1974410167@qq.com',1,1,'2021-03-11 12:14:17.905867');
/*!40000 ALTER TABLE `auth_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user_groups`
--

DROP TABLE IF EXISTS `auth_user_groups`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user_groups` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_user_groups_user_id_group_id_94350c0c_uniq` (`user_id`,`group_id`),
  KEY `auth_user_groups_group_id_97559544_fk_auth_group_id` (`group_id`),
  CONSTRAINT `auth_user_groups_group_id_97559544_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`),
  CONSTRAINT `auth_user_groups_user_id_6a12ed8b_fk_auth_user_id` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user_groups`
--

LOCK TABLES `auth_user_groups` WRITE;
/*!40000 ALTER TABLE `auth_user_groups` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user_user_permissions`
--

DROP TABLE IF EXISTS `auth_user_user_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user_user_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_user_user_permissions_user_id_permission_id_14a6b632_uniq` (`user_id`,`permission_id`),
  KEY `auth_user_user_permi_permission_id_1fbb5f2c_fk_auth_perm` (`permission_id`),
  CONSTRAINT `auth_user_user_permi_permission_id_1fbb5f2c_fk_auth_perm` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`),
  CONSTRAINT `auth_user_user_permissions_user_id_a95ead1b_fk_auth_user_id` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user_user_permissions`
--

LOCK TABLES `auth_user_user_permissions` WRITE;
/*!40000 ALTER TABLE `auth_user_user_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_user_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_admin_log`
--

DROP TABLE IF EXISTS `django_admin_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_admin_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `action_time` datetime(6) NOT NULL,
  `object_id` longtext,
  `object_repr` varchar(200) NOT NULL,
  `action_flag` smallint(5) unsigned NOT NULL,
  `change_message` longtext NOT NULL,
  `content_type_id` int(11) DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `django_admin_log_content_type_id_c4bce8eb_fk_django_co` (`content_type_id`),
  KEY `django_admin_log_user_id_c564eba6_fk_auth_user_id` (`user_id`),
  CONSTRAINT `django_admin_log_content_type_id_c4bce8eb_fk_django_co` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`),
  CONSTRAINT `django_admin_log_user_id_c564eba6_fk_auth_user_id` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=183 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_admin_log`
--

LOCK TABLES `django_admin_log` WRITE;
/*!40000 ALTER TABLE `django_admin_log` DISABLE KEYS */;
INSERT INTO `django_admin_log` VALUES (1,'2021-03-11 12:16:15.521411','1','python',1,'[{\"added\": {}}]',8,1),(2,'2021-03-11 12:16:22.183613','1','pppppython',1,'[{\"added\": {}}]',7,1),(3,'2021-03-11 12:16:24.402840','1','python',1,'[{\"added\": {}}]',9,1),(4,'2021-03-11 12:16:38.549209','2','java',1,'[{\"added\": {}}]',8,1),(5,'2021-03-11 12:16:42.616644','2','java',1,'[{\"added\": {}}]',7,1),(6,'2021-03-11 12:16:44.302101','2','java',1,'[{\"added\": {}}]',9,1),(7,'2021-03-11 12:31:05.108802','1','Text_signature object (1)',1,'[{\"added\": {}}]',11,1),(8,'2021-03-11 14:38:52.027700','2','Text_signature object (2)',1,'[{\"added\": {}}]',11,1),(9,'2021-03-11 15:26:13.012605','2','java',3,'',7,1),(10,'2021-03-11 15:26:13.016117','1','pppppython',3,'',7,1),(11,'2021-03-11 15:26:25.641172','3','闭包',1,'[{\"added\": {}}]',7,1),(12,'2021-03-11 15:26:34.722992','4','nginx',1,'[{\"added\": {}}]',7,1),(13,'2021-03-11 15:26:39.624436','5','部署blog',1,'[{\"added\": {}}]',7,1),(14,'2021-03-11 15:26:43.762603','6','docker',1,'[{\"added\": {}}]',7,1),(15,'2021-03-11 15:26:48.943605','7','java-继承',1,'[{\"added\": {}}]',7,1),(16,'2021-03-11 15:26:54.812304','8','向上转型，向下转型',1,'[{\"added\": {}}]',7,1),(17,'2021-03-11 15:26:59.863376','9','java接口',1,'[{\"added\": {}}]',7,1),(18,'2021-03-11 15:27:04.545935','10','java_abstract',1,'[{\"added\": {}}]',7,1),(19,'2021-03-11 15:27:09.285093','11','装饰器',1,'[{\"added\": {}}]',7,1),(20,'2021-03-11 15:27:13.791237','12','django',1,'[{\"added\": {}}]',7,1),(21,'2021-03-11 15:27:18.018247','13','Scrapy',1,'[{\"added\": {}}]',7,1),(22,'2021-03-11 15:27:22.582763','14','Python特殊方法',1,'[{\"added\": {}}]',7,1),(23,'2021-03-11 15:27:26.280761','15','二分查找',1,'[{\"added\": {}}]',7,1),(24,'2021-03-11 15:27:30.299545','16','java集合',1,'[{\"added\": {}}]',7,1),(25,'2021-03-11 15:27:34.489379','17','python面向对象',1,'[{\"added\": {}}]',7,1),(26,'2021-03-11 15:27:38.786041','18','排序',1,'[{\"added\": {}}]',7,1),(27,'2021-03-11 15:27:42.848407','19','javascript语法',1,'[{\"added\": {}}]',7,1),(28,'2021-03-11 15:27:46.824009','20','Vue',1,'[{\"added\": {}}]',7,1),(29,'2021-03-11 15:27:50.885094','21','数据库',1,'[{\"added\": {}}]',7,1),(30,'2021-03-11 15:27:55.074583','22','三次握手，四次挥手',1,'[{\"added\": {}}]',7,1),(31,'2021-03-11 15:28:01.108670','23','二叉树',1,'[{\"added\": {}}]',7,1),(32,'2021-03-11 15:28:05.241782','24','TCP',1,'[{\"added\": {}}]',7,1),(33,'2021-03-11 15:28:09.197548','25','进程',1,'[{\"added\": {}}]',7,1),(34,'2021-03-11 15:28:14.904544','26','redis',1,'[{\"added\": {}}]',7,1),(35,'2021-03-11 15:28:19.000832','27','单例模式',1,'[{\"added\": {}}]',7,1),(36,'2021-03-11 15:29:14.310922','2','java',3,'',8,1),(37,'2021-03-11 15:29:14.317037','1','python',3,'',8,1),(38,'2021-03-11 15:29:28.359912','3','Python',1,'[{\"added\": {}}]',8,1),(39,'2021-03-11 15:29:32.612969','4','工具',1,'[{\"added\": {}}]',8,1),(40,'2021-03-11 15:29:37.997141','5','杂谈',1,'[{\"added\": {}}]',8,1),(41,'2021-03-11 15:29:43.620637','6','java面向对象',1,'[{\"added\": {}}]',8,1),(42,'2021-03-11 15:29:48.045209','7','PythonWeb框架',1,'[{\"added\": {}}]',8,1),(43,'2021-03-11 15:29:53.236117','8','爬虫框架',1,'[{\"added\": {}}]',8,1),(44,'2021-03-11 15:29:57.502808','9','数据结构和算法',1,'[{\"added\": {}}]',8,1),(45,'2021-03-11 15:30:02.032390','10','Java',1,'[{\"added\": {}}]',8,1),(46,'2021-03-11 15:30:06.251107','11','javascript',1,'[{\"added\": {}}]',8,1),(47,'2021-03-11 15:30:11.283401','12','前端框架',1,'[{\"added\": {}}]',8,1),(48,'2021-03-11 15:30:15.374367','13','数据库',1,'[{\"added\": {}}]',8,1),(49,'2021-03-11 15:30:19.679394','14','计算机网络',1,'[{\"added\": {}}]',8,1),(50,'2021-03-11 15:30:23.781768','15','操作系统',1,'[{\"added\": {}}]',8,1),(51,'2021-03-11 15:30:28.274101','16','设计模式',1,'[{\"added\": {}}]',8,1),(52,'2021-03-11 15:47:03.229448','3','每一行嵌套list : [[1]',3,'',9,1),(53,'2021-03-11 15:52:43.667845','6','闭包',1,'[{\"added\": {}}]',9,1),(54,'2021-03-11 15:55:18.419834','7','装饰器',1,'[{\"added\": {}}]',9,1),(55,'2021-03-11 15:56:51.651125','8','特殊方法__str__和__repr__的区别',1,'[{\"added\": {}}]',9,1),(56,'2021-03-11 15:58:15.253157','9','@property 静态方法 类方法',1,'[{\"added\": {}}]',9,1),(57,'2021-03-11 15:59:00.575525','28','python语法',1,'[{\"added\": {}}]',7,1),(58,'2021-03-11 16:00:03.315623','10','python __init__继承',1,'[{\"added\": {}}]',9,1),(59,'2021-03-11 16:01:32.937187','11','Docker',1,'[{\"added\": {}}]',9,1),(60,'2021-03-11 16:02:18.474372','12','部署博客应用心得',1,'[{\"added\": {}}]',9,1),(61,'2021-03-11 16:03:37.208307','13','nginx基本命令',1,'[{\"added\": {}}]',9,1),(62,'2021-03-11 16:05:02.390215','17','想法',1,'[{\"added\": {}}]',8,1),(63,'2021-03-11 16:06:14.264554','14','大二结束，承前启后！',1,'[{\"added\": {}}]',9,1),(64,'2021-03-11 16:07:40.686676','15','java继承和向上(下)转型',1,'[{\"added\": {}}]',9,1),(65,'2021-03-11 16:08:11.757237','16','java接口',1,'[{\"added\": {}}]',9,1),(66,'2021-03-11 16:09:23.140596','17','java抽象类',1,'[{\"added\": {}}]',9,1),(67,'2021-03-11 16:09:59.468498','18','Django表单',1,'[{\"added\": {}}]',9,1),(68,'2021-03-11 16:10:27.257596','19','Django路由系统',1,'[{\"added\": {}}]',9,1),(69,'2021-03-11 16:12:30.153766','20','django-models',1,'[{\"added\": {}}]',9,1),(70,'2021-03-11 16:13:22.836110','21','Scrapy_callback',1,'[{\"added\": {}}]',9,1),(71,'2021-03-11 16:14:11.955665','22','Scrapy_ImagePipeline',1,'[{\"added\": {}}]',9,1),(72,'2021-03-11 16:15:11.712375','23','二分查找',1,'[{\"added\": {}}]',9,1),(73,'2021-03-11 16:15:51.335310','24','排序',1,'[{\"added\": {}}]',9,1),(74,'2021-03-11 16:16:59.189012','25','二叉树构造，建立，遍历',1,'[{\"added\": {}}]',9,1),(75,'2021-03-11 16:21:44.331509','26','java-集合',1,'[{\"added\": {}}]',9,1),(76,'2021-03-11 16:22:17.410421','27','javascript中的in运算符',1,'[{\"added\": {}}]',9,1),(77,'2021-03-11 16:23:12.700826','28','Vue子组件和父组件的相互传值',1,'[{\"added\": {}}]',9,1),(78,'2021-03-11 16:24:49.431401','29','mysql',1,'[{\"added\": {}}]',7,1),(79,'2021-03-11 16:25:06.368614','29','数据库索引',1,'[{\"added\": {}}]',9,1),(80,'2021-03-11 16:25:56.467031','30','redis入门操作',1,'[{\"added\": {}}]',9,1),(81,'2021-03-11 16:26:30.942009','31','redis持久化',1,'[{\"added\": {}}]',9,1),(82,'2021-03-11 16:27:28.076444','32','TCP三次握手，四次挥手',1,'[{\"added\": {}}]',9,1),(83,'2021-03-11 16:28:13.738997','33','拥塞控制',1,'[{\"added\": {}}]',9,1),(84,'2021-03-11 16:28:43.252978','34','进程概述',1,'[{\"added\": {}}]',9,1),(85,'2021-03-11 16:29:16.656598','35','进程控制块详解',1,'[{\"added\": {}}]',9,1),(86,'2021-03-11 16:29:48.924295','36','进程同步',1,'[{\"added\": {}}]',9,1),(87,'2021-03-11 16:30:30.816883','37','单例模式的python实现',1,'[{\"added\": {}}]',9,1),(88,'2021-03-11 16:31:33.290736','1','About_me object (1)',1,'[{\"added\": {}}]',12,1),(89,'2021-03-11 22:40:07.480800','3','Text_signature object (3)',1,'[{\"added\": {}}]',11,1),(90,'2021-03-16 21:10:49.338373','30','I/O模型',1,'[{\"added\": {}}]',7,1),(91,'2021-03-16 21:10:55.520565','38','五种IO模型详解',1,'[{\"added\": {}}]',9,1),(92,'2021-03-16 21:11:56.736967','38','五种IO模型详解',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(93,'2021-03-16 21:14:29.649098','38','五种IO模型详解',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(94,'2021-03-17 21:02:20.712401','39','innodb和myisam的区别',1,'[{\"added\": {}}]',9,1),(95,'2021-03-21 13:51:13.268606','40','innodb事务性',1,'[{\"added\": {}}]',9,1),(96,'2021-04-11 16:14:46.283480','41','djangorestframework类继承关系',1,'[{\"added\": {}}]',9,1),(97,'2021-04-11 16:43:46.104919','42','djangorestframework最佳实践',1,'[{\"added\": {}}]',9,1),(98,'2021-04-15 21:46:39.465855','31','树',1,'[{\"added\": {}}]',7,1),(99,'2021-04-15 21:46:44.744563','43','前缀树的设计和实现',1,'[{\"added\": {}}]',9,1),(100,'2021-04-15 21:47:23.281342','43','前缀树的设计和实现',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(101,'2021-04-15 22:08:08.982708','4','Text_signature object (4)',1,'[{\"added\": {}}]',11,1),(102,'2021-04-16 16:44:08.205858','32','贪心算法',1,'[{\"added\": {}}]',7,1),(103,'2021-04-16 16:44:09.526219','44','45.跳跃游戏2',1,'[{\"added\": {}}]',9,1),(104,'2021-04-16 16:44:27.974566','44','45.跳跃游戏2',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(105,'2021-04-17 20:55:16.128990','33','想法',1,'[{\"added\": {}}]',7,1),(106,'2021-04-17 20:55:21.491708','45','如何看待退休人员基本养老金涨 4.5% ？具体情况如何？还有',1,'[{\"added\": {}}]',9,1),(107,'2021-04-17 20:56:26.927950','45','如何看待退休人员基本养老金涨 4.5% ？具体情况如何？',2,'[{\"changed\": {\"fields\": [\"\\u6807\\u9898\", \"\\u6b63\\u6587\"]}}]',9,1),(108,'2021-04-17 21:28:13.475118','46','如何看待人大代表建议每周2.5天假期',1,'[{\"added\": {}}]',9,1),(109,'2021-04-17 21:33:07.376793','47','如何看待全国多地提倡非必要不还乡？',1,'[{\"added\": {}}]',9,1),(110,'2021-04-17 21:37:09.025503','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(111,'2021-04-17 21:37:21.768959','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(112,'2021-04-17 21:37:52.803460','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(113,'2021-04-17 21:38:03.215075','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(114,'2021-04-18 13:09:18.301589','45','如何看待退休人员基本养老金涨 4.5% ？具体情况如何？',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(115,'2021-04-18 13:10:58.929878','45','如何看待退休人员基本养老金涨 4.5% ？具体情况如何？',2,'[{\"changed\": {\"fields\": [\"\\u6807\\u7b7e\"]}}]',9,1),(116,'2021-04-18 13:42:53.325879','48','谈谈为什么写这个博客项目',1,'[{\"added\": {}}]',9,1),(117,'2021-04-18 13:56:45.410615','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(118,'2021-04-19 23:59:51.447126','5','Text_signature object (5)',1,'[{\"added\": {}}]',11,1),(119,'2021-05-28 20:07:52.237284','47','如何看待全国多地提倡非必要不还乡？',3,'',9,1),(120,'2021-05-28 20:07:56.940997','46','如何看待人大代表建议每周2.5天假期',3,'',9,1),(121,'2021-05-28 20:17:00.272771','6','Text_signature object (6)',1,'[{\"added\": {}}]',11,1),(122,'2021-05-31 23:46:17.306600','49','占位',1,'[{\"added\": {}}]',9,1),(123,'2021-06-25 15:37:56.369196','49','二叉树，二叉搜索树的相关实现',2,'[{\"changed\": {\"fields\": [\"\\u6807\\u9898\", \"\\u6b63\\u6587\", \"\\u6458\\u8981\", \"\\u5206\\u7c7b\", \"\\u6807\\u7b7e\"]}}]',9,1),(124,'2021-06-25 15:39:56.965126','7','Text_signature object (7)',1,'[{\"added\": {}}]',11,1),(125,'2021-06-25 15:41:49.404971','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(126,'2021-06-25 15:42:29.549240','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(127,'2021-06-25 15:42:51.784524','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(128,'2021-06-25 15:43:03.745696','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(129,'2021-06-25 15:43:22.814003','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(130,'2021-06-28 13:22:21.426060','50','平衡二叉树的相关操作',1,'[{\"added\": {}}]',9,1),(131,'2021-07-03 14:01:35.835371','34','哈希表',1,'[{\"added\": {}}]',7,1),(132,'2021-07-03 14:01:45.874005','35','位运算',1,'[{\"added\": {}}]',7,1),(133,'2021-07-03 14:01:52.775471','51','剑指offer56 数组中数字出现的次数',1,'[{\"added\": {}}]',9,1),(134,'2021-07-03 14:02:29.443577','51','剑指offer56 数组中数字出现的次数',2,'[{\"changed\": {\"fields\": [\"\\u6807\\u7b7e\"]}}]',9,1),(135,'2021-07-05 14:56:27.353629','52','innodb缓冲池和抗扫描',1,'[{\"added\": {}}]',9,1),(136,'2021-07-05 14:57:10.047563','52','innodb缓冲池和抗扫描',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(137,'2021-07-14 15:03:50.463275','36','LRU缓存机制',1,'[{\"added\": {}}]',7,1),(138,'2021-07-14 15:03:58.472485','53','lru缓存机制的实现',1,'[{\"added\": {}}]',9,1),(139,'2021-07-14 15:04:41.007916','53','lru缓存机制的实现',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(140,'2021-07-18 16:45:48.526213','54','redis过期键的实现',1,'[{\"added\": {}}]',9,1),(141,'2021-07-22 15:14:46.072473','48','谈谈为什么写这个博客项目',3,'',9,1),(142,'2021-07-22 15:14:46.076390','45','如何看待退休人员基本养老金涨 4.5% ？具体情况如何？',3,'',9,1),(143,'2021-08-03 18:04:09.789303','55','记一次列表不同操作时间复杂度差别造成的算法性能的巨大差异',1,'[{\"added\": {}}]',9,1),(144,'2021-10-17 14:10:24.102711','18','Golang',1,'[{\"added\": {}}]',8,1),(145,'2021-10-17 14:10:32.260294','37','Golang',1,'[{\"added\": {}}]',7,1),(146,'2021-10-17 14:10:37.006177','56','golang继承，多态，多继承',1,'[{\"added\": {}}]',9,1),(147,'2021-10-28 16:50:16.674961','8','Text_signature object (8)',1,'[{\"added\": {}}]',11,1),(148,'2021-12-05 14:10:48.926165','57','三种装饰器的实现以及装饰器原理',1,'[{\"added\": {}}]',9,1),(149,'2021-12-06 16:07:21.469904','58','迭代器和生成器',1,'[{\"added\": {}}]',9,1),(150,'2022-01-04 23:37:14.108771','38','I/O多路复用',1,'[{\"added\": {}}]',7,1),(151,'2022-01-04 23:37:17.614150','59','I/O多路复用简概',1,'[{\"added\": {}}]',9,1),(152,'2022-01-09 23:40:14.118045','39','go反射',1,'[{\"added\": {}}]',7,1),(153,'2022-01-09 23:40:20.995162','60','Go语言实现remove()函数',1,'[{\"added\": {}}]',9,1),(154,'2022-01-17 00:03:08.480148','60','像操作python List一样操作go Slice',2,'[{\"changed\": {\"fields\": [\"\\u6807\\u9898\", \"\\u6b63\\u6587\"]}}]',9,1),(155,'2022-01-23 00:45:50.837504','40','协程',1,'[{\"added\": {}}]',7,1),(156,'2022-01-23 00:45:54.819735','61','论协程',1,'[{\"added\": {}}]',9,1),(157,'2022-02-05 23:19:34.166330','62','redis简单动态字符串SDS实现',1,'[{\"added\": {}}]',9,1),(158,'2022-02-05 23:20:25.816759','63','redis链表实现',1,'[{\"added\": {}}]',9,1),(159,'2022-02-05 23:20:55.002089','64','redis哈希表实现',1,'[{\"added\": {}}]',9,1),(160,'2022-02-06 18:06:26.714926','65','Redis跳跃表实现',1,'[{\"added\": {}}]',9,1),(161,'2022-02-06 18:06:58.225055','66','redis整数集合实现',1,'[{\"added\": {}}]',9,1),(162,'2022-02-06 18:07:26.602528','67','redis压缩列表实现',1,'[{\"added\": {}}]',9,1),(163,'2022-02-07 16:41:50.841986','41','HTTPS',1,'[{\"added\": {}}]',7,1),(164,'2022-02-07 16:42:14.628746','68','https原理',1,'[{\"added\": {}}]',9,1),(165,'2022-02-08 12:56:01.679082','69','redis持久化之RDB',1,'[{\"added\": {}}]',9,1),(166,'2022-02-08 12:56:35.525847','70','redis持久化之AOF',1,'[{\"added\": {}}]',9,1),(167,'2022-02-14 18:25:08.466455','71','Redis复制',1,'[{\"added\": {}}]',9,1),(168,'2022-02-14 18:25:28.260199','72','redis哨兵',1,'[{\"added\": {}}]',9,1),(169,'2022-02-14 18:26:15.641997','73','redis集群基础',1,'[{\"added\": {}}]',9,1),(170,'2022-02-14 18:26:54.520376','74','redis集群-复制与故障转移',1,'[{\"added\": {}}]',9,1),(171,'2022-07-19 18:22:46.942700','1','About_me object (1)',2,'[{\"changed\": {\"fields\": [\"\\u5173\\u4e8e\"]}}]',12,1),(172,'2023-04-17 17:12:40.878652','19','微服务',1,'[{\"added\": {}}]',8,1),(173,'2023-04-17 17:12:47.017550','20','分布式',1,'[{\"added\": {}}]',8,1),(174,'2023-04-17 17:13:24.030537','42','微服务',1,'[{\"added\": {}}]',7,1),(175,'2023-04-17 17:13:28.063177','43','分布式',1,'[{\"added\": {}}]',7,1),(176,'2023-04-17 17:13:37.318829','75','redis分布式锁的实现',1,'[{\"added\": {}}]',9,1),(177,'2023-04-17 17:15:10.900444','75','redis分布式锁的实现',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(178,'2023-04-17 17:17:40.230217','75','redis分布式锁的实现',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(179,'2023-04-17 17:23:32.042337','75','redis分布式锁的实现',2,'[{\"changed\": {\"fields\": [\"\\u6b63\\u6587\"]}}]',9,1),(180,'2023-07-29 13:01:32.720670','76','Go垃圾回收',1,'[{\"added\": {}}]',9,1),(181,'2023-07-29 13:03:21.429768','9','Text_signature object (9)',1,'[{\"added\": {}}]',11,1),(182,'2023-10-25 17:19:51.925645','10','Text_signature object (10)',1,'[{\"added\": {}}]',11,1);
/*!40000 ALTER TABLE `django_admin_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_content_type`
--

DROP TABLE IF EXISTS `django_content_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_content_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app_label` varchar(100) NOT NULL,
  `model` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `django_content_type_app_label_model_76bd3d3b_uniq` (`app_label`,`model`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_content_type`
--

LOCK TABLES `django_content_type` WRITE;
/*!40000 ALTER TABLE `django_content_type` DISABLE KEYS */;
INSERT INTO `django_content_type` VALUES (1,'admin','logentry'),(3,'auth','group'),(2,'auth','permission'),(4,'auth','user'),(5,'contenttypes','contenttype'),(12,'mainapp','about_me'),(8,'mainapp','category'),(10,'mainapp','comment'),(9,'mainapp','post'),(7,'mainapp','tag'),(11,'mainapp','text_signature'),(6,'sessions','session');
/*!40000 ALTER TABLE `django_content_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_migrations`
--

DROP TABLE IF EXISTS `django_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_migrations` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `applied` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_migrations`
--

LOCK TABLES `django_migrations` WRITE;
/*!40000 ALTER TABLE `django_migrations` DISABLE KEYS */;
INSERT INTO `django_migrations` VALUES (1,'contenttypes','0001_initial','2021-03-10 19:35:08.740066'),(2,'auth','0001_initial','2021-03-10 19:35:08.873600'),(3,'admin','0001_initial','2021-03-10 19:35:09.238217'),(4,'admin','0002_logentry_remove_auto_add','2021-03-10 19:35:09.366615'),(5,'admin','0003_logentry_add_action_flag_choices','2021-03-10 19:35:09.377147'),(6,'contenttypes','0002_remove_content_type_name','2021-03-10 19:35:09.456343'),(7,'auth','0002_alter_permission_name_max_length','2021-03-10 19:35:09.529254'),(8,'auth','0003_alter_user_email_max_length','2021-03-10 19:35:09.572225'),(9,'auth','0004_alter_user_username_opts','2021-03-10 19:35:09.582477'),(10,'auth','0005_alter_user_last_login_null','2021-03-10 19:35:09.627399'),(11,'auth','0006_require_contenttypes_0002','2021-03-10 19:35:09.629279'),(12,'auth','0007_alter_validators_add_error_messages','2021-03-10 19:35:09.642262'),(13,'auth','0008_alter_user_username_max_length','2021-03-10 19:35:09.699902'),(14,'auth','0009_alter_user_last_name_max_length','2021-03-10 19:35:09.744560'),(15,'auth','0010_alter_group_name_max_length','2021-03-10 19:35:09.828188'),(16,'auth','0011_update_proxy_permissions','2021-03-10 19:35:09.846477'),(17,'auth','0012_alter_user_first_name_max_length','2021-03-10 19:35:09.937226'),(18,'sessions','0001_initial','2021-03-10 19:35:09.991372'),(19,'mainapp','0001_initial','2021-03-10 19:42:29.342057'),(20,'comments','0001_initial','2020-01-31 05:14:19.573177');
/*!40000 ALTER TABLE `django_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_session`
--

DROP TABLE IF EXISTS `django_session`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_session` (
  `session_key` varchar(40) NOT NULL,
  `session_data` longtext NOT NULL,
  `expire_date` datetime(6) NOT NULL,
  PRIMARY KEY (`session_key`),
  KEY `django_session_expire_date_a5c62663` (`expire_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_session`
--

LOCK TABLES `django_session` WRITE;
/*!40000 ALTER TABLE `django_session` DISABLE KEYS */;
INSERT INTO `django_session` VALUES ('135mt5mxb1d6non9ci0canvp6j509h75','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-12-09 09:44:43.150078'),('1elmjspyqcehmsrv2gbnowxnn63g7jop','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1mbyuX:O_hWjjNtFufKofxhdNFiGJnrHjw-SHaNHokSAxC4798','2021-10-31 13:40:41.736077'),('28q1v3jau82lwids4hvh4bgrqa6nhn44','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lmbGw:WVuAkspwszmqHE2Ksyd2ZdQ781PqZ5MRi3PMBNPuP-U','2021-06-11 20:07:26.627827'),('2ppa9uq1pqa03ywbh2qut2k7prp2o7ph','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-06-16 13:15:11.170505'),('34n7iwk1rvqpvceohs71xg6832olmqvs','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lLfEK:I46tlWs47I23EXM8kMssTl4iWP1cYh07SDtxydmCtIU','2021-03-29 12:53:24.725696'),('3de8mm8r43if4vxjkau1g51pe6je0aga','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lYWJA:2Jx6cg9sNhktti_Uc3QRmZN60dKeSQP-KxD0V1Fam7I','2021-05-03 23:59:32.447259'),('3fls9056i2of300iijqzdm8zqe50yo7v','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-03-12 18:31:18.891448'),('50g4ziwprraj52fkyeso1qfxwktvac8n','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lMVmx:zgICzd3VIF_f4CfpFQ94RE9D_HWWgdqzxikMybnS5Rc','2021-03-31 21:00:39.838558'),('52xa8pxx626518r89m0smwpjyzu8bpxz','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-05-16 15:14:50.272319'),('5gdtin74zvacvgk26qlux140xmjlkv3o','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1n4lpQ:ZQzyVre8CGV99BJ3_Mhb2RwT-8LTSrn0uMLMYYrzC_Q','2022-01-18 23:34:24.188240'),('5u0grj856cmbvj6tjijrunewae6n5778','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1nBJVk:bW_fWgKwkh9y_7O51bmQr2hkkmT2JS5POdU6trtVlkk','2022-02-06 00:45:08.389657'),('62hedh72sb2t13p17hnsla44a2vo4hg0','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1qPc3X:FaCAhsZ6X90gjZkx3hDE_pRVfz_3ipSFa9PzpkEwBAA','2023-08-12 12:59:55.574392'),('6fk0f92pged0adzuhgkihodm2g2e1sui','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1m3Yub:cd7_mTXOq1xeNK_Kt5OtRJHOWRTDfNUr0ch6mxtqN0w','2021-07-28 15:02:29.987610'),('9dyi0ypjvved7tlx8qgihymfr8j15z6o','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-02-22 07:01:41.647825'),('aq0883yl3kh932elqkvup2gbyvbiwb7j','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-09-29 11:40:09.579264'),('bw9umolw85mnynwhqy8hfgj0quacx741','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-12-17 11:55:25.366733'),('chcpl51royzqyh6jpdbzfcy07w2lcx38','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-03-11 15:23:17.356544'),('clueymmeaccaana54t1l1bb5sqjg1d0a','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-03-19 13:54:48.330586'),('d7drq4p40o3d76zncfo1bngr7xbpl63f','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lKCji:-fwoP-Rl23K2AXpOSCw-fjMlLZPHZva9ghnF0ggf5ig','2021-03-25 12:15:46.973029'),('dd2a1g7nawkz2qwpsmmtemuqwkum3vuo','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-10-12 03:53:25.365291'),('dg89vsc1k4gptv54c1c52nigww6waw5b','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1m52PZ:B5rME3vMR_CEAzuaoI0aNQQMo-d_T0ybfDpeFNiTcIo','2021-08-01 16:44:33.705975'),('dla0nv5oi61v98bbclrdobijizj4immv','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1poHxf:eQMWdzumwIGKOAGiQu-elu4gCV7wALrM8v0uWTuTfMM','2023-05-01 14:03:35.113196'),('e2xc4y0nqcw4dk4uc541zxc2iqybw307','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-03-11 12:13:32.678045'),('e5zxkqbz4ahqm3l0r0ce2jo5cscxes5z','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lX2Jd:27QLqMKB85IOqcrJFVWij7uFEm_xZC3QHLGAtSqQ8FI','2021-04-29 21:45:53.230004'),('ebhavf3zc4p7sxdewt304zhc7hafjorp','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-09-29 11:49:59.004050'),('fu290pikdgab22prdagjnwuznzov56aj','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-02-25 09:06:56.080255'),('gw0rgu6aciksf7yo4rntriwxm9wwfnj3','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lX2ap:K67LQq8vrSSqjqUCzBVUFyWfE75IA0G6mi-ONoYcT5U','2021-04-29 22:03:39.163225'),('hr05bquuoyn55hd2jsqvdtwy8r588bx8','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-12-01 05:37:11.515532'),('k397p9ihjy48bdn6vi28r1ptn5hls1nn','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1nGeQZ:hZP87phLxbOdDH1lRDwfy1VzDquQ59KoZs1gSNa71S8','2022-02-20 18:05:51.554162'),('ka05gierfrmkh4sabmzbvz1017nn2idm','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lKEus:iJgqOKUyV1fPCbT7FlOSq3GJP3AcG-ogf4fXpwHIX3U','2021-03-25 14:35:26.542555'),('kd3jjteyoto716u9je40lk80ry5ov43y','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2021-01-31 11:48:36.016135'),('km74z2842y7cywrspo82a78udbtkqu9q','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-12-25 06:49:46.848821'),('knzjvybyhz48hks3lrw9owplnv8l7t29','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lnk6V:n5oFP8PkCPsEGbNqEsP3O6ExkJakXKyVW5rmO61Sei4','2021-06-14 23:45:23.217920'),('ky1ndgy6nwx4ieidjmtpkmi2w1uc1v6o','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-04-15 16:32:16.678382'),('lphvhvgzwjogpzprteqef6fth955rcey','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lKMTN:5Qbl3q5Jn4x9JZbv8skAqp7aTSQ9iDarqS0ULeFzsgY','2021-03-25 22:39:33.550269'),('muz8ctod37f73d74l3agvidv6bcrdajd','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1mtkgW:2M4kfzxtFE-WpHVlxmtCzybZSTCioilkj7LVdLgnZvc','2021-12-19 14:07:40.435103'),('n77mklc197jqw9lc7z2g0ene8cmvjumc','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-07-27 12:54:14.884815'),('osy7v0su6sqf9bvecfjrbhrvjwjgqjxz','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-08-20 06:59:13.515888'),('p4xfpm9q9q5q5a75v51c7rzgwmdmvahg','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1mArGE:-xol61pne_tFWO1np_MCaRn1JqqW9gDcIh8ylpDtKD8','2021-08-17 18:02:58.794421'),('pkxpbnb92dn9m2vbf96xigu8gpuxnhmt','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-03-11 11:48:13.429289'),('pqsk50vif5n4fa3noq21f4vcrfujs1hm','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-10-28 09:08:30.651130'),('q6nlyr7cepbfpwyi2tzgcktnolf12bxz','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lVVEY:Zy4XriZU-8ouzZ0fOk76DQzhBWH-CiL4L2DOvu8OUZo','2021-04-25 16:14:18.238900'),('qds2abm73p2f7ay2rslwfb32x8i7ihdr','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1lwgFj:xdrhuZBjqHX8Po3THRWG_Q7Ox4fftj4HZbnDUg0bG2Y','2021-07-09 15:27:51.816868'),('qzvpbj6hl1703760qemvooun6xkzwwxb','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-09-21 09:19:46.931761'),('rbvixa0nr2i4cekhwlfl56n46vz8jsww','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-03-13 09:01:05.464118'),('s4oa3cmiuv2srjnpxn0kdxytfi0oc3qy','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-04-24 17:28:59.855662'),('saej8jmfz38i7jde9gsz8wud96c2jt23','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1oDkLr:7enMuEzt_EPsTX3B7TSlweKN661QCzE-NO77V9yno-U','2022-08-02 18:21:15.765141'),('suirui5llohkbff0pdndibeyloi33k9x','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1qva2z:01Nf9QGdmR906O4rq74OFaf-L0ANhqxuw3Gkx1YwkJ0','2023-11-08 17:19:29.430350'),('t1sl1xv4epqrwbh4icg6ufsr0h00sqh0','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1naBwe:UXlROQ9tdyp0MWvAYHA7K_ak0Ar0U-K4cg4mmpHMH9k','2022-04-15 15:43:44.057726'),('twkrm1y69dukthjzalkfm1h23jry1x61','.eJxVjEEOwiAQRe_C2hCHoci4dN8zkAGmUjU0Ke3KeHfbpAvdvvf-f6vA61LC2mQOY1ZXBer0yyKnp9Rd5AfX-6TTVJd5jHpP9GGb7qcsr9vR_h0UbmVbW8_OW3PxYAhJ0DJ6YIPoYkodOBDPlhKaM2CmYaCIGzDixGafqVOfL61NNvE:1n97vu:NBiQNREPl5zyzFlINdJaQ4V5uDan6SeDABtZ-AQypvk','2022-01-30 23:59:06.307515'),('vkeoz8hmho179dw92ta4yfak3tfljvq8','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-11-06 11:09:22.891357'),('wdaagizx1becbi3sclq45jzikzee2lme','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2021-02-06 14:18:33.750177'),('xngoxwgagqrhvi1brczshmgd9tiz14hb','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-04-02 14:47:00.014509'),('xwntjmw0uzil8i8yi7g9l8r69ftrk8ms','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-09-29 11:50:32.967315'),('zhk0b08ljh7cpwvpx8qju207q9y413vp','ZDRhMGQ2NTVmODQ4MzkwNTUxZWI4ZDQ2ZjcwNmU3Mzk1NDRhMDMzZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIxN2M0ZjkwMTBkM2MwMTg2OTkwNzkyYjZmZjMxNGFmMDNiNDljZmNjIn0=','2020-02-04 13:03:57.655370');
/*!40000 ALTER TABLE `django_session` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mainapp_about_me`
--

DROP TABLE IF EXISTS `mainapp_about_me`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mainapp_about_me` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `text` longtext NOT NULL,
  `created_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mainapp_about_me`
--

LOCK TABLES `mainapp_about_me` WRITE;
/*!40000 ALTER TABLE `mainapp_about_me` DISABLE KEYS */;
INSERT INTO `mainapp_about_me` VALUES (1,'00后，Golang/Python开发工程师，LOL钻石选手。','2021-03-11 16:31:33.288785');
/*!40000 ALTER TABLE `mainapp_about_me` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mainapp_category`
--

DROP TABLE IF EXISTS `mainapp_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mainapp_category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mainapp_category`
--

LOCK TABLES `mainapp_category` WRITE;
/*!40000 ALTER TABLE `mainapp_category` DISABLE KEYS */;
INSERT INTO `mainapp_category` VALUES (3,'Python'),(4,'工具'),(5,'杂谈'),(6,'java面向对象'),(7,'PythonWeb框架'),(8,'爬虫框架'),(9,'数据结构和算法'),(10,'Java'),(11,'javascript'),(12,'前端框架'),(13,'数据库'),(14,'计算机网络'),(15,'操作系统'),(16,'设计模式'),(17,'想法'),(18,'Golang'),(19,'微服务'),(20,'分布式');
/*!40000 ALTER TABLE `mainapp_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mainapp_comment`
--

DROP TABLE IF EXISTS `mainapp_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mainapp_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `email` varchar(254) NOT NULL,
  `text` longtext NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `post_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `mainapp_comment_post_id_0a35514f_fk_mainapp_post_id` (`post_id`),
  CONSTRAINT `mainapp_comment_post_id_0a35514f_fk_mainapp_post_id` FOREIGN KEY (`post_id`) REFERENCES `mainapp_post` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mainapp_comment`
--

LOCK TABLES `mainapp_comment` WRITE;
/*!40000 ALTER TABLE `mainapp_comment` DISABLE KEYS */;
INSERT INTO `mainapp_comment` VALUES (1,'访客','fangke@qq.com','good','2021-03-15 12:25:50.372130',37),(2,'访客','fangke@qq.com','nice','2021-03-15 12:26:45.953379',36),(3,'访客','fangke@qq.com','beautiful','2021-03-15 12:30:16.862635',37),(4,'访客','fangke@qq.com','xixi','2021-03-15 12:31:19.222907',37),(5,'访客','fangke@qq.com','111','2021-03-15 12:31:38.080570',34),(6,'访客','fangke@qq.com','hah','2021-03-15 12:32:16.811932',37),(7,'访客','fangke@qq.com','啊','2021-03-15 12:32:31.312957',7),(8,'访客','fangke@qq.com','沙发','2021-03-15 12:33:08.239820',35),(9,'访客','fangke@qq.com','地板','2021-03-15 12:33:15.840461',35),(10,'访客','fangke@qq.com','嗷嗷','2021-03-15 12:44:12.872611',37),(11,'访客','fangke@qq.com','dd','2021-03-15 12:47:07.183528',37),(12,'访客','fangke@qq.com','asdasd','2021-03-15 12:47:12.959652',37),(14,'访客','fangke@qq.com','478578587857','2021-06-08 15:41:18.315660',35),(15,'访客','fangke@qq.com','xx','2022-01-04 23:37:41.879149',59),(16,'访客','fangke@qq.com','aa','2022-01-04 23:37:47.040753',59),(17,'访客','fangke@qq.com','1','2022-01-04 23:37:59.577984',59),(18,'访客','fangke@qq.com','77','2022-01-20 16:13:31.498547',19),(19,'访客','fangke@qq.com','牛逼','2022-01-23 17:02:21.994782',61),(20,'q','fangke@qq.com','牛哇','2022-04-04 17:47:14.968106',68),(21,'访客','fangke@qq.com','牛啊','2022-08-26 22:33:09.902733',35),(22,'访客','fangke@qq.com','牛逼','2022-08-26 22:33:21.921731',74);
/*!40000 ALTER TABLE `mainapp_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mainapp_post`
--

DROP TABLE IF EXISTS `mainapp_post`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mainapp_post` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(30) NOT NULL,
  `body` longtext NOT NULL,
  `create_time` datetime(6) NOT NULL,
  `modified_time` datetime(6) NOT NULL,
  `excerpt` varchar(200) NOT NULL,
  `pageviews` int(11) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `mainapp_post_category_id_1581664c_fk_mainapp_category_id` (`category_id`),
  KEY `mainapp_post_create_time_7cef7ca7` (`create_time`),
  CONSTRAINT `mainapp_post_category_id_1581664c_fk_mainapp_category_id` FOREIGN KEY (`category_id`) REFERENCES `mainapp_category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=77 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mainapp_post`
--

LOCK TABLES `mainapp_post` WRITE;
/*!40000 ALTER TABLE `mainapp_post` DISABLE KEYS */;
INSERT INTO `mainapp_post` VALUES (6,'闭包','>   新冠病毒依然在肆虐，不过天天在家也未尝不可，正好把Fuluenly Python看看，聊聊闭包，用我的理解解释一下。\r\n\r\n\r\n\r\n#### 了解局部变量，全局变量与自由变量\r\n\r\n##### 局部变量\r\n\r\n\r\n    def fun(n):\r\n        n+1\r\n        print(n)\r\n    \r\n    >>> fun(3)\r\n    4\r\n\r\n   \r\nn为局部变量，只在函数体内有效。\r\n\r\n##### 全局变量\r\n\r\n\r\n\r\n    a=1\r\n    def fun(n):\r\n        global a\r\n        a += 1\r\n        print(a)\r\n        print(n)\r\n    \r\n    >>> fun(3)\r\n    2\r\n    3\r\n\r\n\r\n         \r\na为全局变量并且为不可变数据类型，只能访问不能修改，若要修改，用global声明\r\n\r\n##### 自由变量\r\n\r\n这里直接借用《Fluently Python》书中例子,这个例子是向一个列表添加新值，并计算出添加新值后的平均值\r\n\r\n\r\n\r\n    def make_av():\r\n        series=[]\r\n        def av(new_value):\r\n            series.append(new_value)\r\n            total=sum(series)\r\n            return total/len(series)\r\n        return av\r\n    >>> avg=make_av()\r\n    >>> avg(10)\r\n    10\r\n    >>> avg(11)\r\n    10.5\r\n\r\n\r\n\r\n如果一直添加新值，list占据内存将不断增大，所以，优化，只存储目前的总值和元素个数。\r\n\r\n\r\n\r\n    def make_av():\r\n        count=0\r\n        total=0\r\n        def av(new_value):\r\n            count+=1\r\n            total+=new_value\r\n            return total/count\r\n        return av\r\n    >>> avg=make_av()\r\n    >>> avg(10)\r\n    \r\n    UnboundLcoalError:\r\n    \r\n\r\n\r\n这个错误是显而易见的，函数内不能修改函数外的不可变变量，而这里count+=1,试图修改make_av函数体内的变量，那么该如何才能访问呢，首先不能用global，因为这是声明全局变量，而count不是全局变量，所以python3引入了nonlocal,它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。\r\n\r\n所以，正确实现如下\r\n\r\n\r\n    def make_av():\r\n        count=0\r\n        total=0\r\n        def av(new_value):\r\n            nonlocal count,total\r\n            count+=1\r\n            total+=new_value\r\n            return total/count\r\n        return av\r\n\r\n\r\n\r\n\r\n\r\n>   所以，闭包，是指延伸了作用域的函数，就如前文中av函数，包含定义体中(av)引用，但是不在定义体中定义的非全局变量(count和total)。','2021-03-11 15:52:43.661257','2023-12-23 15:54:02.356227','Python中的闭包',35,3),(7,'装饰器','> 如果对闭包理解较为深刻，那么装饰器就很简单了\r\n\r\n> 通俗的讲就是将函数A作为参数传给函数B，在B内部进行一顿操作，然后B返回A。\r\n\r\n\r\n\r\n首先实现一个简单的装饰器\r\n\r\nclock_demo.py\r\n\r\n\r\n    import time\r\n    import functools\r\n    def clock(func):\r\n    \r\n        @functools.wraps(func) #把被装饰函数相关属性从func复制到clocked中\r\n        def clocked(*args,**kwargs):  # 1\r\n            t0=time.time()  \r\n            result=func(*args,**kwargs)  \r\n            elapsed=time.time()-t0\r\n            name= func.__name__\r\n            arg_list =[]\r\n            if args:\r\n                arg_list.append(\", \".join(repr(arg)for arg in args))\r\n            if kwargs:\r\n                pairs=[\"%s=%r\"%(k,w) for k,w in sorted(kwargs.items())]\r\n                arg_list.append(\", \".join(pairs))\r\n            arg_str=\", \".join(arg_list)\r\n            print(\'[%0.8fs]%s(%s)->%r\'%(elapsed,name,arg_str,result))\r\n    \r\n            return result\r\n    \r\n        return clocked\r\n\r\n\r\n\r\n这个装饰器实现了四个功能\r\n- 打印函数运行时间\r\n- 打印函数名\r\n- 打印函数参数(位置参数和关键字参数)\r\n- 返回函数的返回值\r\n\r\n\r\n实现一个斐波那契数列      \r\nfactorial1.py    \r\n\r\n\r\n    import time\r\n    from clock_demo import clock\r\n    @clock\r\n    def fibonacci(n):\r\n        if n<2:\r\n            return 1\r\n        return fibonacci(n-2)+fibonacci(n-1)\r\n    \r\n    if __name__==\"__main__\":\r\n        print(fibonacci(6))\r\n        \r\n    \r\n\r\n\r\n![348D9s.png](https://s2.ax1x.com/2020/03/03/348D9s.png)\r\n\r\n可以看到经过装饰的斐波那契数列输出了每个数的值。','2021-03-11 15:55:18.406948','2023-12-23 15:54:02.418413','装饰器的一个小例子',36,3),(8,'特殊方法__str__和__repr__的区别','> __str__和__repr__都是为了返回对终端用户友好的字符串提示。区别在于，后者是在str()函数被使用，或是在用print函数打印一个对象的时候才调用，并且它返回的字符串对终端用户更友好。如果想实现这两个特殊方法中的一个，__repr__是更好的选择，因为如果一个对象没有__str__函数，而python又需要调用它的时候，解释器会用__repr__替代，反之不行。\r\n\r\n\r\n- 只实现__repr__\r\n\r\n        \r\n        \r\n        \r\n        class aa():\r\n            def __init__(self):\r\n                self.list1 = [i for i in range(3)]\r\n\r\n            def __repr__(self):\r\n                return f\"aa{self.list1}\"\r\n\r\n        t = aa()\r\n        print(t)                        (1)\r\n        aa[0, 1, 2]\r\n        print(t.__str__())              (2)\r\n        aa[0, 1, 2]\r\n        print(t.__repr__())             (3)\r\n        aa[0, 1, 2]\r\n    \r\n\r\n\r\n\r\n\r\n(1)可以看到print打印对象t，打印的却是__repr__函数的返回值，这是因为没有实现__str__,但是print函数需要调用它，解释器就用__repr__函数取而代之。                \r\n\r\n(2)打印__str__函数\r\n\r\n(3)打印__repr__函数\r\n\r\n\r\n\r\n- 只实现__str__\r\n\r\n    \r\n        class aa():\r\n            def __init__(self):\r\n                self.list1 = [i for i in range(3)]\r\n\r\n            def __str__(self):\r\n                return f\"aa{self.list1}\"\r\n\r\n        t = aa()\r\n        print(t)                                        (1)\r\n        aa[0, 1, 2]                                  \r\n        print(t.__str__())                              (2)\r\n        aa[0, 1, 2]\r\n        print(t.__repr__())                             (3)\r\n        <__main__.aa object at 0x000001C71142F940>  \r\n\r\n\r\n(1) 打印t,调用__str__\r\n(2) 打印__str__方法\r\n(3) 打印__repr__方法,没实现。','2021-03-11 15:56:51.645485','2023-12-23 15:54:02.495971','__str__和__repr__',31,3),(9,'@property 静态方法 类方法','- @property\r\n    - @property就是把方法变成属性调用\r\n    - 可以检查参数是否合法\r\n    - 将属性设为只读\r\n\r\n\r\n\r\n        class Person(object):\r\n        def __init__(self):\r\n            self._name = None\r\n            self.__age = None\r\n    \r\n        @property\r\n        def name(self):\r\n            return self._name\r\n    \r\n        @property\r\n        def age(self):\r\n            return self.__age\r\n    \r\n        @age.setter\r\n        def age(self,age):\r\n            if age>=18:\r\n                raise ValueError(\'请输入小于18的数字\')\r\n            else:\r\n                self.__age = age\r\n                    \r\n            \r\n            \r\n        t = Person()\r\n        t.age = 23                  （1）\r\n        ValueError: 请输入小于18的数字\r\n        t.age = 13                   \r\n        t.age\r\n        13\r\n        t.name = \"Xx\"                （2）\r\n        AttributeError: can\'t set attribute\r\n        \r\n\r\n\r\n\r\n（1） 检查age是否大于18，若大于，触发ValueError              \r\n（2） name属性为只读，若赋值，触发AttributeError\r\n\r\n\r\n- @classmethod\r\n\r\n        \r\n        class Student(object):\r\n    \r\n        score = 60\r\n    \r\n        def run(self):\r\n            print(\"跑步贼快\")\r\n    \r\n        @classmethod\r\n        def fun(cls):\r\n            print(cls.score)\r\n            cls().run()\r\n    \r\n        >>> Student.fun()\r\n        60  \r\n        跑步贼快\r\n        \r\n\r\n(1) 不用创建实例，就可以访问类方法                  \r\n(2) cls为约定俗成，代表当前类的信息的对象\r\n\r\n\r\n- @staticmethod\r\n\r\n    \r\n        from math import sqrt\r\n    \r\n        class Triangle(object):\r\n    \r\n        def __init__(self, a, b, c):\r\n            self._a = a\r\n            self._b = b\r\n            self._c = c\r\n    \r\n        @staticmethod\r\n        def is_valid(a, b, c):\r\n            return a + b > c and b + c > a and a + c > b\r\n    \r\n        def perimeter(self):\r\n            return self._a + self._b + self._c\r\n    \r\n        def area(self):\r\n            half = self.perimeter() / 2\r\n            return sqrt(half * (half - self._a) *\r\n                        (half - self._b) * (half - self._c))\r\n                        \r\n        def main():\r\n            a,b,c = 3,4,1\r\n            # 静态方法和类方法都是通过给类发消息来调用的\r\n            if Triangle.is_valid(a, b, c):\r\n                t = Triangle(a, b, c)\r\n                print(t.perimeter())\r\n                # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数\r\n                # print(Triangle.perimeter(t))\r\n                print(t.area())\r\n                # print(Triangle.area(t))\r\n            else:\r\n                print(\'无法构成三角形.\')\r\n        if __name__ == \'__main__\':\r\n            main()\r\n\r\n        \r\n> staticmethod差不多，但是static从来没有不得不用的情况，就如上述代码，验证a,b,c是否是合法的三角形边，完全可以在同一模块中类前或者类后定义','2021-03-11 15:58:15.244519','2023-12-23 15:54:02.500276','property,classmethod,staticmethod',30,3),(10,'python __init__继承','> 如果子类继承父类，且子类重写__init__,那么将不继承父类的属性\r\n\r\n> 如果子类继承父类，且子类不写__init__,那么将继承父类的所有属性\r\n\r\n> 如果子类继承父类，且子类重写__init__,要想继承父类属性，要用super().__init__()\r\n\r\n\r\n    class person(object):\r\n        def __init__(self,name):\r\n            self.name = name\r\n        def run(self):\r\n            return f\'{self.__class__.__name__} is running\'\r\n    class student(person):\r\n        def __init__(self,age,name):\r\n            self.age = age\r\n            super(student,self).__init__(name)\r\n\r\n\r\n    a = student(12,\'xx\')\r\n    print(a.run())\r\n    \r\n    student is running','2021-03-11 16:00:03.310105','2023-12-23 15:54:02.431715','python 初始化函数的继承',37,3),(11,'Docker','> 学docker是为了部署django应用，也就是这个blog(尽管到最后并没有用docker部署)\r\ndocker，即镜像，容器，仓库。\r\n\r\n- 镜像(image)\r\n\r\n镜像来自于仓库(当然也可以自己编写dockerfile文件，创建自定义镜像)，但是你会发现你从dockerhub拉下来的image(比如ubuntu)是小于它的真实大小的，这是因为image是层层叠加的，镜像文件会共用一些相同的层\r\n\r\n- 容器    \r\n\r\n用来运行镜像的地方。\r\n\r\n- 仓库\r\n\r\n放置image的地方\r\n\r\n所以docker是这样运作的，你运行一个镜像，先在本地查看是否有这个镜像，如果没有就会从仓库(例如dockerhub)上拉取，然后在容器内运行，或者自定义dockerfile生成你自己的镜像.\r\n\r\n\r\n-----\r\n下面是docker常见指令\r\n\r\n\r\n\r\n\r\n\r\n#### 列出已经在本地的镜像\r\ndocker images                 列出所有image      \r\ndocker images -a              列出所有image  包含中间层       \r\ndocker images -q              列出所有image的ID    \r\n#### 从互联网查找镜像\r\ndocker search tomcat          查找所有tomcat镜像     \r\ndocker search -s tomcat       查找星数最多的tomcat     \r\ndocker search -s 30 tomcat    查找星数超过30的tomcat     \r\ndocker search -s --no-trunc tomcat        显示完整的image描述     \r\n\r\n#### 从互联网拉取镜像\r\ndocker pull tomcat   默认拉取最新镜像到本地\r\n\r\n#### 删除镜像\r\ndocker rmi tomcat    删除镜像   \r\ndocker rmi -f 镜像ID    -f 表示强制删除       \r\ndocker rmi -f 镜像ID1 镜像ID2  删除多个镜像    \r\ndocker rmi -f tomcat 强制删除   \r\ndocker rmi -f $(docker images -q)  删除docker images -q 的所有返回对象    \r\n                                   类似与sql语句  where id in (id1,id2.....) \r\n#### 开启容器与运行中的容器                \r\ndocker ps [option] 列出所有运行中的容器    \r\n  - -a 列出当前所有正在运行的容器+历史上运行过的\r\n  - -l 显示最近创建的容器\r\n  - -n + x显示最近创建的x个容器\r\n  - -q 静默模式，只显示容器的编号\r\n  - --no-trunc 不截断输出    \r\ndocker run -it  centos    以centos为镜像，生成一个容器，并交互式命令启动        \r\ndocker run -it --name mycentos centos   以centos为镜像，并命名为mycentos,生成一个容器，并运行      \r\ndocker run [option] imageID\r\n  - -d 后台运行，并返回容器ID，也即启动守护式容器\r\n  - -i 以交互模式运行容器，通常与-t同时使用\r\n  - -t 为容器重新分配一个伪终端，通常与-i同时使用\r\n  - -P 随机端口映射\r\n#### 关闭容器\r\nexit  容器停止退出    \r\nctrl+P+Q  容器不停止退出      \r\ndocker start imageID  启动已经关闭的容器     \r\ndocker restart imageID  重启运行中的容器\r\ndocker stop imageID  温柔关闭  类似与按下电脑关机键\r\ndocker kill inageID  快速关闭  类似与直接拔掉电源\r\n\r\n#### 删除容器\r\ndocker rm imageID  删除单个容器\r\ndocker rm -f $(docker ps -a -q)  删除多个容器   -f  强制删除\r\n\r\n\r\n#### docker容器后台运行，就必须有一个前台进程，否则后台程序会自动停止，最佳解决方案是将要运行的程序以前台进程的形式运行\r\ndocker run -d imageID 并不能真的在后台运行     \r\ndocker run -d imageID /bin/sh -s \'while true;do echo hello zzyy;sleep 2;done\'  这个可以运行，因为前台需要每隔两秒，不停的打印 hello zzyy.    \r\n\r\n#### 查看容器日志\r\ndocker logs imageID  查看容器日志\r\ndocker logs -t imageID 显示日志时间戳\r\ndocker logs -t -f imageID 显示日志时间戳,并打印\r\n\r\n#### 查看容器内运行的进程\r\ndocker top imageID\r\n\r\n#### 进入后台已经在运行的容器\r\n- docker attach imageID            直接进入容器启动命令的终端，不会启动新的进程\r\n- docker exec -it imageID /bin/bash 在容器中打开新的终端，并且可以启动新的进程\r\n\r\n#### 拷贝容器里面的文件到宿主机\r\ndocker cp 容器id:/tmp/yum.log /root   拷贝容器 tmp/yum.log 到宿主机/root下\r\n\r\n#### 指定端口启动容器\r\ndocker run -it -p 8888:8080 tomcat 指定容器端口为8888，并启动(8080为容器内部tomcat的端口)\r\ndocker run -it -P tomcat 随机为一个端口启动容器    \r\n\r\n#### 修改已经运行的容器后，将其成为新的镜像\r\ndocker commit -m=\'提交信息\' -a=\'作者\' 容器ID 要创建的目标镜像名：[标签名]\r\n\r\n#### 数据卷的特点\r\n  - 数据卷可在容器之间共享或重用数据\r\n  - 卷中的更改可以直接生效\r\n  - 数据卷中的更改不会包含在镜像的更新中\r\n  - 数据卷的生命周期一直持续到没用容器使用它为止\r\n \r\n#### 容器与宿主机的数据共享\r\ndocker run -it -v /myDataVolume:/dataVolumeContainer centos  在宿主机根目录下新建myDataVolume文件夹，在容器根目录下新建dataVolumeContain文件夹      \r\n值得注意的是，不管容器是否运行，数据卷里边文件内容都会同步，在容器重新运行的时候，容器与宿主机文件会自动进行同步\r\n\r\ndocker run -it -v /myDataVolume:/dataVolumeContainer:ro centos     \r\n容器可同步宿主机文件，但是不能修改，添加，删除宿主机文件\r\n\r\n#### 创建docker镜像\r\n/mydocker: docker build -f /mydocker/Dockerfile -t 镜像名  根目录下创建mydocker，然后进入mydocker,在mydocker文件夹内执行命令    \r\n\r\n#### 容器间的继承与数据共享\r\n    \r\n    \r\n    --volumes-from 容器间传递共享    \r\n    \r\n\r\n\r\ndocker run -it --name dc02 --volumes-from dco1  imageID 容器dc02继承容器dc01,并共享数据卷数据，以imageID为模板    \r\n\r\n容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止\r\n#### DockerFile\r\n- FROM 基础镜像，当前镜像是基于哪个镜像的\r\n- MAINTAINER 镜像维护者的姓名和邮箱地址\r\n- RUN 容器构造时需要运行的命令\r\n- EXPOSE 当前容器对外暴露出的端口\r\n- WORKDIR 指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点\r\n- ENV 用来在构建镜像过程中设置环境变量\r\n- ADD 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包\r\n- COPY 类似ADD，拷贝文件和目录到镜像中，将从构建上下文目录中<源路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置\r\n- VOLUME 容器数据卷，用于数据保存和持久化工作\r\n- CMD\r\n  - 指定一个容器启动时要运行的命令\r\n  - DockerFile中可以有多个CMD指令，但只有最后一个会生效，CMD会被docker run之后参数替换\r\n- ENTRYPOINT\r\n  - 指定一个容器启动时要运行的命令\r\n  - ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序和参数，但是ENTRYPOINT是追加\r\n- ONBUILD 当构建一个被继承的Dockerfile时运行的命令，父镜像在被子镜像继承后父镜像的onbuild被触发','2021-03-11 16:01:32.922907','2023-12-23 15:54:02.476457','对docker的拙见以及常见命令',44,4),(12,'部署博客应用心得','> 如果一件事你想到了，那么你就一定能做到    \r\n\r\n谈谈写这个blog应用的动机以及历程吧。\r\n\r\n大二上学期，在工作室朋友的建议下，用hexo和github搭建了博客，搭建完我发现这博客不能随时随地编写(因为需要在本地命令行操作，将代码push到github上)，顿时感觉自己花费好几天时间搭建的博客就是一个垃圾，恰好当时在学django,萌生了用django自己搭建博客的想法，决定在寒假，把blog搭建了。\r\n\r\n实话说，django框架是真的强大，你根本无需去关注细枝末节的问题，一个requests通过url到views,views编个函数，render返回请求，完事了，让我头大的是前端页面的问题，因为对前端几乎不懂，所以想修改个布局都费好大劲(这让我萌生了系统的学习html+css+js的念头)。写代码过程并没有遇到什么困难，大多是拼写错误，部署却花了我半个月时间(服务器备案+不停的试错)。\r\n\r\n刚开始是直接把代码从github上clone到服务器，然后运行，发现这样只能前台运行，不能干别的事，然后又用gunicorn,后台运行，但是用gunicorn不能加载static文件,最后用nginx处理static,才把blog运行起来了。到最后又遇到很多坑，一个个爬出来，才实现了可以通过域名访问blog,这些坑大概是这样的:       \r\n- 无法通过公网IP访问  ->  添加应用端口到安全组\r\n- 无法通过域名访问 ->  不仅域名需要解析到服务器IP，服务器那边也需要绑定域名，解析域名。\r\n- 各种解析都整完后依然无法访问，显示非法阻断，最后提交工单，华为云客服告诉我，把我服务禁止了？给我解除阻断就行了 -> 我tm搞个网站又没犯法，给我阻断干嘛？','2021-03-11 16:02:18.468848','2023-12-23 15:54:02.442574','为什么写这个博客以及遇到了哪些坑',35,5),(13,'nginx基本命令','> Nginx(engine x)一个高性能的HTTP和反向代理的web服务器  --百度百科\r\n\r\n- 启动\r\n> sudo systemctl start nginx\r\n- 停止\r\n> sudo systemctl stop nginx\r\n- 重启\r\n> sudo systemctl restart nginx\r\n- 如果您只是简单地进行配置更改，Nginx通常可以重新加载而不会丢失连接。为此，请输入：\r\n> sudo systemctl reload nginx\r\n- 默认情况下，Nginx配置为在服务器引导时自动启动。 如果这不是您想要的，可以通过输入以下命令来禁用此行为：\r\n> sudo systemctl disable nginx                        \r\n\r\n\r\n> nginx命令都在/usr/sbin/nginx中  在/usr/sbin/nginx下可以执行相关操作\r\n\r\n\r\n\r\n\r\n### Nginx配置文件的结构和最佳做法\r\n- 所有Nginx配置文件都位于/etc/nginx目录中。\r\n- 主要的Nginx配置文件为/etc/nginx/nginx.conf。\r\n- 为使Nginx配置更易于维护，建议为每个域创建一个单独的配置文件。您可以根据需要拥有任意数量的服务器块文件。\r\n- Nginx服务器块文件存储在/etc/nginx/sites-available目录中。除非它们链接到/etc/nginx/sites-enabled目录，否则Nginx不会使用此目录中找到的配置文件。\r\n- 要激活服务器块，您需要从以下目录中的配置文件站点创建符号链接（指针）将sites-available目录移到sites-enabled目录。\r\n- 建议遵循标准命名约定，例如，如果您的域名是mydomain.com，则您的配置文件应命名为/etc/nginx/sites-available/mydomain.com.conf  ]\r\n- /etc/nginx/snippets目录包含可包含在服务器块文件中的配置片段。如果使用可重复的配置段，则可以将这些段重构为片段，并将片段文件包括到服务器块中。\r\n- Nginx日志文件（access.log和error.log）位于/var/log/nginx目录中。建议每个服务器块使用不同的access和error日志文件。\r\n\r\n\r\n\r\n> 在Nginx的配置文件/etc/nginx/nginx.conf中需要将第一行的\'user nobody;\'改为\'user root\',否则就算收集静态文件也无法加载\r\n\r\n    server {\r\n        charset utf-8;\r\n        listen 80;\r\n        server_name 域名;\r\n     \r\n        location /static {\r\n            alias > /root/my_blog/blogproject/blog;   #静态文件绝对目录\r\n        }\r\n     \r\n        location / {\r\n            proxy_set_header Host $host;\r\n            proxy_pass http://127.0.0.1:8000;        #匹配/static又nginx处理，其余转发至8000端口\r\n        }\r\n    }','2021-03-11 16:03:37.193191','2023-12-23 15:54:02.411721','nginx基本操作',37,13),(14,'大二结束，承前启后！','大二已经结束两周了。\r\n\r\n回顾前两年，喜忧参半！\r\n\r\n大一加入ACM，正式开始摸鱼。大一整个一年都在摸索着入门。不过幸好，虽然花费了一年时间，但是总算是入门了。\r\n\r\n大一的时候会试着写一些简单爬虫，或者破解学校教务系统之类的，技术含量不高，但是给我带来的成就感是溢于言表的。\r\n\r\n大二开始学习一些专业课程，计算机组成原理，数据结构，操作系统，数据库，还学了一门java。讲实话，计算机组成原理没学，但是操作系统与数据库自我感觉学的还可以，书上写的各种算法，用计算机语言实现问题不大。由于之前大一自学了C语言，python也用的较为熟练，所以java学起来很快，但是也仅限于熟练使用java的语法，java的那些牛逼的生态并没有去学。\r\n\r\n大二开始试着学一些web框架，用django搭建了自己的博客，就是现在这个。学了flask,自我感觉写一个小型的服务端的应用不成问题。写web应用，把数据库搞好，把服务端搞好，剩下的就是前端了。\r\n\r\n暑假快要结束，我去图书馆借了基本比较厚重的书，比如《高性能MYSQL》，《TCL/IP详解》，打算暑假把这些看完。然后暑假我又想着搞钱。就无意间想到或许可以搬运视频赚钱，到各大视频网站一搜发现已经有很多人干这样的事情了。\r\n\r\n我想着把youtube视频搬到国内。就写了几个脚本，脚本直接调用youtube-dl接口，然后自己给多加了个多线程下载。这个事想住简单，干起来挺麻烦的，从youtube下载下来的视频是没有字幕的，我要把相应的中文字幕也下载下来，然后合并，这个挺花费时间,主要是吃CPU，合并视频和字幕，CPU负荷直接拉满，整个笔记本感觉要爆炸了。刚开始挺好，搬几个视频火了一个，直接一个视频赚了百十块，慢慢的平台好像发现是搬运的了，千次播放单价就降到了原来的一半，每天就给几块钱，我就泄气了。所以还是老实练习编程将来搬砖把。\r\n\r\n这只是一个小插曲。\r\n\r\n大二前两年算是知道了学什么，怎样学。所以这里定一个后两年的计划。\r\n\r\njavasctipt在大二暑假学了，vue也写了。成为一个伪全栈工程师，将来有啥想法自己撸起袖子就干。\r\n\r\n另一方面需要精进自己的后端，所以我借了《高性能MYSQL》。另一方面，就是把django，flask等后端框架吃透了。\r\n\r\n未完待续！','2021-03-11 16:06:14.257732','2023-12-23 15:54:02.426837','回顾前两年，喜忧参半！',43,5),(15,'java继承和向上(下)转型','####    继承\r\n- 由protected修饰的属性或方法，整个继承树均可以访问\r\n- 由private修饰的属性或方法，子类不可访问，但可以通过setXXX(),getXXX()方法设置访问。\r\n- 任何class的构造方法，第一行必须是调用父类的构造方法，如果没有明确的调用父类的构造方法，编译器会自动帮我们添加一句super();,所以父类实现的构造方法，子类也需要实现\r\n\r\n\r\n    public class Person{\r\n        protected String name;\r\n        protected int age;\r\n    \r\n        public Person(String name){\r\n            this.name=name;  #父类构造方法\r\n        }\r\n    \r\n        public int getAge() {\r\n            return age;\r\n        }\r\n    \r\n        public String getName() {\r\n            return name;\r\n        }\r\n    \r\n        public void setAge(int age) {\r\n            this.age = age;\r\n        }\r\n    \r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            Person name1=new Person(\"小明\");\r\n            Student name2=new Student(\"小命名\"，60)；\r\n    \r\n        }\r\n        public void Say(){\r\n            System.out.println(\"I am person\");\r\n        }\r\n    \r\n    \r\n    \r\n    }\r\n    class Student extends Person{\r\n        protected int score;\r\n    \r\n        public Student(String name,int score){\r\n            super(name);           #子类构造方法，必须实现父类构造方法属性，\r\n            this.score=score;\r\n        }\r\n        public int getScore(){\r\n            return score;\r\n        }\r\n        public void setScore(int score){\r\n            this.score=score;\r\n        }\r\n        @Override\r\n        public void Say(){\r\n            System.out.println(\"I am Student\");\r\n        }\r\n    \r\n    \r\n    }\r\n    \r\n- 向上转型(把子类型安全的变为更加抽象的父类型,增加可扩展性)\r\n\r\n\r\n        Person name3=new Student();\r\n        name3.setScore(70);   # 报错，向上转型，丢失与父类不同的方法\r\n        name3.Say();           # 输出> \"I am Student\"\r\n\r\n这是允许的，name3是Person变量，Student继承Person,拥有Person的全部功能，所以name3指向Student()类型的实例，对他进行操作时允许的，但是会丢失score属性和方法，即向上转型会丢失子类特有的方法(子类的@Override方法不会丢失)。                       \r\n如何避免丢失子类特有属性？向下转型\r\n\r\n                             \r\n-  向下转型                                                      \r\n        \r\n        \r\n        Student name4=(Studnet) name3;\r\n        name4.setScore(70)     # 不报错','2021-03-11 16:07:40.680793','2023-12-23 15:54:02.372395','继承，向上转型，向下转型',20,6),(16,'java接口','### 接口(interface)\r\n\r\n如果一个抽象类没有字段，所有方法全部都是抽象方法，那么可以将其声明为接口(interface)\r\n\r\n    public abstract class Person1{\r\n        public abstract void run();\r\n    }\r\n    \r\n因为接口定义所有方法默认都是public abstract,所以这两个修饰符可以不写\r\n\r\n即\r\n\r\n    \r\n    interface Person1{\r\n        void run();\r\n    }\r\n#### 类继承接口\r\nclass继承接口，用implements关键字\r\n\r\n   \r\n    class Student_ming implements Person1{\r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"i can run\");\r\n        }\r\n    }\r\n\r\n一个类不能多重继承多个类，但是一个类可以继承多个接口\r\n\r\n    \r\n    interface Person2{\r\n        void say()\r\n    }\r\n    class Student_ming implements Person1,Person2{\r\n       //继承Person1,Person2\r\n       \r\n       @Override\r\n       public void run(){...};\r\n       \r\n       @Override\r\n       public void say(){...};\r\n       \r\n    }\r\n\r\n#### 接口继承接口\r\n\r\n    interface Person1 extends Psrson2{\r\n        // 相当于扩展接口，Person1继承Person2接口所有方法\r\n        void run();\r\n        void say();\r\n    } \r\n    \r\n    \r\n#### default\r\n\r\n如果我们在接口中新增一个方法，那么会涉及修改所有子类，很麻烦，但是新增的方法时如果default方法，那么子类不必修改所有子类，只需要在需要覆写的子类中覆写即可\r\n\r\n\r\n在接口中实现的default方法，实现类不必覆写.\r\n\r\n\r\n    interface Person3{\r\n        void eat();\r\n        default void write_code(){\r\n            System.out.println(\"i can write code\");\r\n        }\r\n    }\r\n    class people implements Person3{\r\n        // 仅仅覆写eat()方法，不必覆写default()方法\r\n        @Override\r\n        public void eat(){\r\n            System.out.println(\"i can eat\");\r\n        }\r\n    }','2021-03-11 16:08:11.747832','2023-12-23 15:54:02.541493','java接口基本用法',20,6),(17,'java抽象类','#### 抽象类(abstract)\r\n\r\n> 有时候父类的方法没有意义，因为子类方法总是覆写父类方法，这时候父类的方法不需要实现任何的功能，仅仅是为了定义方法签名,目的是让子类覆写它，那么可以将方法声明为抽象方法(类似于python中一个方法仅写函数名，然后函数体中仅写pass用于占位) ，因为抽象方法无法执行，也就是Person1实例无法抽象化，所以必须把Person1类也声明为abstract.\r\n\r\n如下:\r\n    \r\n    public abstract class Person1 {\r\n        public abstract void run();\r\n    }\r\n    \r\n    class Student1 extends Person1{\r\n        @Override\r\n        public void run(){\r\n            System.out.println(\"Student1 running\");\r\n        }\r\n    }\r\n    class Tercher1 extends Person1{\r\n        @override\r\n        public void run(){\r\n            System.out.println(\"Teacher1 running\");\r\n        }\r\n    }\r\n    \r\n    class main {\r\n        public static void main(String[] args) {\r\n            Person1 a= new Student1();\r\n            Person1 b= new Student1();\r\n            a.run();\r\n            b.run();\r\n        }\r\n    \r\n    }\r\n    >>>Student1 running\r\n    >>>Teacher1 running\r\n\r\n即                \r\n- 父类定义规范\r\n- 子类必须实现父类的抽象方法\r\n- 具体业务逻辑由不同子类实现，调用者无需关心。','2021-03-11 16:09:23.134986','2023-12-23 15:54:02.435463','抽象类的意义',20,6),(18,'Django表单','#### 表单\r\n\r\ndjango用表单的流程大约是这样的，在forms.py中创建表单类，继承Form或者ModelForm,views中导入表单，然后编写视图，视图返回大约是这样的\r\n\r\n    return render(request, \'name.html\', {\'form\': form})\r\n    \r\n把表单传入name.html,并加以渲染。\r\n\r\n\r\n所有表单类都作为django.forms.Form或者django.forms.ModelForm创建\r\n\r\n- django.froms.Form\r\n\r\nfroms.py (表单类NameForm继承forms.Form,并定义your_name字段)\r\n\r\n    from django import forms\r\n\r\n    class NameForm(forms.Form):\r\n        your_name = forms.CharField(label=\'Your name\', max_length=100)\r\n        \r\nviews.py (视图函数大约是这样的，如果以get方式访问，将返回空表单，如果以post方式访问，将用post的值填充表单，并判断是否合法)\r\n\r\n    from .forms import NameForm\r\n\r\n    def get_name(request):\r\n        if request.method == \'POST\':\r\n            form = NameForm(request.POST)\r\n            if form.is_valid():\r\n                return HttpResponseRedirect(\'/html1/\')\r\n        else:\r\n            form = NameForm()\r\n\r\n        return render(request, \'name.html\', {\'form\': form})\r\n        \r\nname.html (这里只需要传入变量form,django会自动渲染表单，其中action是url的值)\r\n\r\n    \r\n    <form action=\"/your-name/\" method=\"post\">\r\n        {% csrf_token %}\r\n        {{ form }}\r\n        <input type=\"submit\" value=\"Submit\">\r\n    </form>\r\n    \r\nurls.py  \r\n\r\n            \r\n        from django.urls import path\r\n    from . import views\r\n    urlpatterns = [\r\n    path(\'your-name/\', views.get_name),\r\n    ]\r\n    \r\n最后渲染的浏览器界面是这样的\r\n\r\n![3HDYaF.png](https://s2.ax1x.com/2020/03/05/3HDYaF.png)\r\n\r\n\r\n- django.forms.ModelForm\r\n\r\n如果用到与django模型密切相关的表单，可以用ModelForm\r\n\r\nfroms.py (导入models中的Student模型，以name和address为表单字段)\r\n\r\n\r\n    from django import forms\r\n    from .models import Student\r\n    \r\n    class Student_form(forms.ModelForm):\r\n    class Meta:\r\n        model = Student\r\n        fields = [\'name\',\'address\']\r\n    \r\nviews.py (如果表单请求为post,判断是否合法，打印表单数据，并调用save()传入数据库)\r\n\r\n    def studnet_views(request):\r\n        my_form = Student_form()\r\n        if request.method == \"POST\":\r\n            my_form = Student_form(request.POST)\r\n            if my_form.is_valid():\r\n            print(my_form.cleaned_data)\r\n            my_form.save()\r\n        context = {\r\n            \'form\' : my_form\r\n        }\r\n        return render(request,\'form.html\',context)\r\n        \r\nform.html (继承base.html(也许以后我写关于template的文章会提到这一部分)，直接把上下文变量\"form\"传入)\r\n\r\n    {% extends \"base.html\" %}\r\n\r\n    {% block content %}\r\n\r\n\r\n    <form action=\"/my_form/\" method=\"POST\">\r\n\r\n    {% csrf_token %}\r\n\r\n    {{ form }}\r\n\r\n    <input type=\"submit\" value=\"Submit\">\r\n    </form>\r\n\r\n    {% endblock %}\r\n    \r\nurls.py\r\n\r\n            from django.urls import path\r\n    from . import views\r\n    urlpatterns = [\r\n    path(\'my_form/\', views.student_views),\r\n    ]\r\n    \r\n渲染出来的浏览器页面大概是这样的\r\n\r\n![3Hy1KI.png](https://s2.ax1x.com/2020/03/05/3Hy1KI.png)\r\n\r\n关于表单还有很多细枝末节的东西，这里只有关于表单的流程并且让你感受django表单系统的强大\r\n\r\n更多细节请点击<https://docs.djangoproject.com/zh-hans/2.2/topics/forms/>','2021-03-11 16:09:59.460903','2023-12-23 15:54:02.368222','表单的两个类”Form“ and \"ModelForm\",使用表单的流程',27,7),(19,'Django路由系统','### 路由\r\n\r\n> 毫无疑问，django的路由系统也是简洁而优雅的\r\n\r\n#### url匹配\r\n\r\n路由匹配的背后是正则表达式，django则对正则表达式进行了封装，让url匹配变得更简单。\r\n\r\n比如匹配一个整数\r\n\r\n        path(\'detail/<int:my_id>/\', views.detail_view)\r\n        \r\n匹配一个字符串\r\n\r\n    path(\'search/<str:name>/\', views.name_view)\r\n\r\n\r\n\r\n当人你依然可以用正则\r\n\r\n    re_path(r\'^articles/(?P<year>[0-9]{4})/$\', views.year_archive)\r\n\r\n这将匹配一个四位正整数，并作为year变量的值\r\n\r\n这只是一些例子，更多请点击<https://docs.djangoproject.com/zh-hans/2.2/topics/http/urls/#path-converters>\r\n\r\n---\r\n\r\n- include\r\n\r\n一个项目往往有很多个app,如果所有url都放到跟urls里面，这是愚蠢的，所以可以在其他app中分别创建urls,然后在跟urls中将其include\r\n\r\n\r\n比如在跟urls中\r\n\r\n\r\n    urlpatterns = [\r\n        path(\'admin/\', admin.site.urls),\r\n        path(\'\',include(\'app.urls\'))\r\n    ]\r\n    \r\n    \r\n然后在app.urls中写只属于本应用的路由\r\n\r\n    app_name = \"app\"\r\n    urlpatterns = [\r\n        path(\'user/\',views.user),\r\n        path(\'requ/\',views.TestView.as_view()),\r\n    ]\r\n\r\n---\r\n#### 反向解析\r\n\r\n有时候url需要嵌入到html中，或者重定向中，硬编码是个可行的方法，但也是也费力不易扩展并且容易出错的方法。所以反向解析是个不错的方法\r\n\r\n\r\n反向命名空间，也就是给urls起个名字，好根据名字找到url,这里为urls起名为\"app\"\r\n\r\n    app_name = \"app\"\r\n    path(\'detail/<int:my_id>/\', views.detail_view，name=\'detail_url\')\r\n    \r\n给url命名,将\'detail/<int:my_id>/\'命名为\'detail_url\'\r\n\r\n            path(\'detail/<int:my_id>/\', views.detail_view，name=\'detail_url\')\r\n            \r\n--- \r\n\r\n在模板中使用url模板标签,这样可以直接找到url,并传入参数i.pk，生成url\r\n\r\n    {% for i in context %}\r\n    <li><a href=\"{% url \'app:detail_url\' i.pk %}\">{{ i.pk }}</a></li>\r\n    <li><a>{{ i.name }}</a></li>\r\n    <li><a>{{ i.address }}</a></li>\r\n    \r\n---\r\n- reverse()\r\n\r\n\r\n> reverse（viewname，urlconf = None，args = None，kwargs = None，current_app = None）\r\n\r\n\r\n        path(\'detail/<int:my_id>/\', views.detail_view，name=\'detail_url\')\r\n        \r\n可以用以下任何一种方法来反向url\r\n\r\n直接传入url名字\r\n\r\n    reverse(\'detail_url\')    # 根据url名字反向url\r\n    \r\n如果接受参数，可传入位置参数args\r\n\r\n    def myview(request):\r\n        return HttpResponseRedirect(reverse(\'arch-summary\', args=[1945]))\r\n        \r\n或者关键字参数kwargs\r\n\r\n    reverse(\'admin:app_list\', kwargs={\'app_label\': \'auth\'})\r\n\r\n\r\n\r\n---\r\n\r\n- get_absolute_url()\r\n\r\n\r\n在与Django模型实例的URL处理相关的高级代码中：get_absolute_url()方法。这里定义一个\'get_absolute_url\'方法，返回这个模型的id.\r\n\r\n    class Student(models.Model):\r\n\r\n        name = models.CharField(max_length=120)\r\n        address = models.CharField(max_length=120)\r\n\r\n        def __str__(self):\r\n            return self.name\r\n\r\n        def get_absolute_url(self):\r\n            return reverse(\'app:detail_url\',args=[str(self.id)])\r\n            \r\n\r\n用get_absolute_url()方法的话，模板中嵌入url更简单。这里直接传入get_absolute_url(),返回值为url。\r\n\r\n    {% for i in context %}\r\n    <li><a href=\"{{ i.get_absolute_url }}\">{{ i.pk }}</a></li>\r\n    <li><a>{{ i.name }}</a></li>\r\n    <li><a>{{ i.address }}</a></li>\r\n\r\n\r\n更多细节请移步<https://docs.djangoproject.com/zh-hans/2.2/topics/http/urls/>','2021-03-11 16:10:27.243378','2023-12-23 15:54:02.360853','路由系统的使用',34,7),(20,'django-models','> ORM(Object Relational Mapping)\r\n\r\n把字段一一映射到数据库，django自带的数据库是sqlite3,当然你也可以再setting中配置你自己的数据库\r\n\r\n官网（https://docs.djangoproject.com/zh-hans/3.0/topics/db/models/）\r\n\r\n        \r\n        \r\n    DATABASES = {\r\n    \'default\': {\r\n        \'ENGINE\': \'django.db.backends.sqlite3\',\r\n        \'NAME\': os.path.join(BASE_DIR, \'db.sqlite3\'),\r\n    }\r\n    }\r\n\r\n\r\n- 字段   \r\n\r\n像定义数据库表一样，定义模型类，比如\r\n\r\n    \r\n    class Person(models.Model):\r\n        first_name = models.CharField(max_length=30)\r\n        last_name = models.CharField(max_length=30)\r\n        \r\n等价于(PostreSQL格式)\r\n\r\n\r\n    CREATE TABLE myapp_person (\r\n    \"id\" serial NOT NULL PRIMARY KEY,\r\n    \"first_name\" varchar(30) NOT NULL,\r\n    \"last_name\" varchar(30) NOT NULL\r\n    );\r\n    \r\n\r\n常见字段有CharField,IntegerField,EmailField等\r\n\r\n- 字段选项\r\n\r\n常见字段\r\n\r\nmax_length,当字段类型为CharField是必须指定\r\nnull,对应数据库中的NULL，默认为false     \r\nblank,与null不同，null是数据库层面，blank是表单验证方面\r\nchoices,一系列二元组，提供选择框，比如\r\n\r\n    \r\n    YEAR_IN_SCHOOL_CHOICES = [\r\n    (\'FR\', \'Freshman\'),\r\n    (\'SO\', \'Sophomore\'),\r\n    (\'JR\', \'Junior\'),\r\n    (\'SR\', \'Senior\'),\r\n    (\'GR\', \'Graduate\'),\r\n    ]\r\n\r\n二元组第一个是用于传输的数据，第二个是人性化的文本      \r\ndefault,默认值\r\nprimary_key,外键\r\n\r\n\r\n- Meta\r\n\r\n\r\n模型属性\r\n\r\n常见选项有ordering(排序)，db_table(为模型指定的数据库表名)\r\n\r\n模型方法\r\n\r\n\r\n    __str__()\r\n\r\n返回值友好的展示一个对象\r\n\r\n    get_absolution_url()\r\n\r\n计算一个url\r\n\r\n当然也可以重写django内部的模型方法，如重写save()函数\r\n\r\n    from django.db import models\r\n\r\n    class Blog(models.Model):\r\n        name = models.CharField(max_length=100)\r\n        tagline = models.TextField()\r\n\r\n        def save(self, *args, **kwargs):\r\n            do_something()\r\n            super().save(*args, **kwargs)  # Call the \"real\" save() method.\r\n            do_something_else()','2021-03-11 16:12:30.147888','2023-12-23 15:54:02.492237','django模型',23,7),(21,'Scrapy_callback','> 学scrapy学了两天了，然后今天半夜(0:19)突然把回调搞明白了\r\n\r\n\r\n直接上代码\r\n\r\n\r\n    class QuotesSpider(scrapy.Spider):\r\n        name = \"quotes\"\r\n        start_urls = [\r\n            \"http://quotes.toscrape.com/page/1/\"\r\n        ]\r\n        \r\n        def parse(self, response):\r\n            abouts = response.xpath(\"//div[@class=\'quote\']//span//a/@href\").getall()  (1)\r\n            for about in abouts:\r\n                print(\"$\"*40)\r\n                yield response.follow(about,callback=self.aboutparse)  (2)\r\n\r\n            next_page = response.xpath(\"//li[@class=\'next\']/a/@href\").get() (3)\r\n            if next_page is not None:\r\n                print(\"+\"*40)\r\n                yield response.follow(next_page,callback=self.parse) (4)\r\n\r\n        def aboutparse(self,response):\r\n            author = response.xpath(\"//div[@class=\'author-details\']//h3/text()\").get() (5)\r\n            print(\"#\"*40)\r\n            print(author)\r\n            yield {author:author}\r\n            \r\n            \r\n- name 爬虫名\r\n- start_urls 爬取的第一个url链接\r\n- (1) 得到页面所有作者的链接\r\n- (2) 用解析函数aboutparse对单个作者链接进行处理(这里follow内部直接把相对url拼接成了绝对url)\r\n- (3) 得到\"下一页\"，并递归式调用，继续用本函数(parse)处理\"下一页\"\r\n- (4) 递归调用parse\r\n- (5) 根据作者链接，得到作者名，并yield，\r\n\r\n\r\n> 框架属实强大，只有xpath需要手动(在浏览器开发者工具里边选中元素直接右键\"copy xpath\",这样说的话好像xpath也不需要手动)编写。','2021-03-11 16:13:22.829995','2023-12-23 15:54:02.488243','scrapy.callback和一个小例子',25,8),(22,'Scrapy_ImagePipeline','### Files Pipeline                      \r\n\r\n当使用Files Pipeline 下载文件的时候，按照一下步骤来完成\r\n\r\n- 定义好一个Item,然后在这个item中定义两个属性，分别为file_urls以及files。file_urls是用来存储需要下载文件的url链接，需要给一个列表。\r\n- 当文件下载完之后，会把文件下载的相关信息存储到item的files属性中。比如下载路径，下载的url和文件的校验码等。\r\n- 在配置文件settings.py中配置FILES_STORE,这个配置是用来设置文件下载下来的路径。\r\n- 启动pipeline: 在ITEM_PIPELINES中设置scrapy.piplines.files.FilePipeline:1。\r\n\r\n\r\n\r\n### Images Pipeline\r\n\r\n当使用Image Pipeline下载文件的时候，按照以下步骤完成          \r\n\r\n- 定义好一个Item,然后在这个item中定义两个属性，分别为image_urls以及images。image_urls是用来存储需要下载文件的url链接，需要给一个列表。\r\n- 当文件下载完之后，会把文件下载的相关信息存储到item的images属性中。比如下载路径，下载的url和文件的校验码等。\r\n- 在配置文件settings.py中配置IMAGES_STORE,这个配置是用来设置文件下载下来的路径。\r\n- 启动pipline: 在ITEM_PIPELINES中设置scrapy.piplines.images.imagesPipeline:1。\r\n\r\n\r\n\r\n例如(Images Pipeline)\r\n\r\n\r\n- items.py中定义item \r\n\r\n    \r\n        \r\n        class MvtpItem(scrapy.Item):\r\n\r\n        image_urls = scrapy.Field()\r\n        images = scrapy.Field()\r\n        \r\n\r\n- settings.py中配置pipeline,设置FilePipeline;设置FILES_STORE\r\n\r\n\r\n        ITEM_PIPELINES = {\r\n            #\'MVTP.pipelines.MvtpPipeline\': 300,\r\n            \'scrapy.pipelines.images.ImagesPipeline\':1,\r\n        }\r\n    \r\n        IMAGES_STORE = os.path.join(os.path.dirname(os.path.dirname(__file__)),\'images\')\r\n    \r\n    \r\n- spiders中生成image_urls(列表形式)\r\n\r\n\r\n            class MvspiderSpider(scrapy.Spider):\r\n        name = \'mvspider\'\r\n        allowed_domains = [\'desk.zol.com.cn\']\r\n        start_urls = [\'http://desk.zol.com.cn/meinv/hot_1.html\']\r\n\r\n        def parse(self, response):\r\n            details = response.xpath(\"//a[@class=\'pic\']/@href\").getall()\r\n            for detail in details:\r\n                yield response.follow(detail,callback=self.parse_detail)\r\n\r\n            main_next_page = response.xpath(\"//div[@class=\'page\']//a[@class=\'next\']/@href\").get()\r\n            if main_next_page is not None:\r\n                yield response.follow(main_next_page,callback=self.parse)\r\n\r\n        def parse_detail(self,response):\r\n\r\n            image_urls = response.xpath(\"//img[@id=\'bigImg\']/@src\").getall()   ##(1) image_urls\r\n\r\n            item = MvtpItem(image_urls=image_urls)                             ##(2) 填充item字段\r\n            yield item                                                         ##(3) 生成item\r\n\r\n            detail_next_page = response.xpath(\"//a[@id=\'pageNext\']/@href\").get()\r\n            false_url = \'javascript:;\'\r\n            if detail_next_page is not None and false_url not in detail_next_page:\r\n            yield response.follow(detail_next_page,callback=self.parse_detail)','2021-03-11 16:14:11.945320','2023-12-23 15:54:02.484247','Scrapy框架FilePipeline和ImagePipeline',31,8),(23,'二分查找','- 二分查找对要查找的序列有要求，序列必须按照一定规则顺序排列。\r\n\r\n- 时间复杂度为以2为底，序列长度的对数。\r\n\r\n- 核心思想就是不断的和序列的中间值比较。\r\n\r\n## 迭代法\r\n\r\n    def f1(s,t):\r\n    \r\n        nums = s\r\n        while nums:\r\n    \r\n            l = len(nums)\r\n            mid = nums[l // 2]\r\n    \r\n            if t>mid:\r\n                nums = nums[l//2+1:]\r\n    \r\n            elif t<mid:\r\n                nums = nums[:l//2]\r\n            else:\r\n                return True\r\n        return False\r\n\r\n\r\n## 递归法\r\n    \r\n    \r\n    def f2(s,t):\r\n\r\n        if not s:\r\n            return False\r\n    \r\n        l = len(s)\r\n        mid_index = l//2\r\n    \r\n        mid = s[mid_index]\r\n    \r\n        if mid>t:\r\n            return f2(s[:mid_index],t)\r\n    \r\n        elif mid<t:\r\n            return f2(s[mid_index+1:],t)\r\n        else:\r\n            return True','2021-03-11 16:15:11.706607','2023-12-23 15:54:02.446443','迭代法，递归法解决二分查找',24,9),(24,'排序','### 冒泡排序\r\n\r\n\r\n    def bubble_sort(num):\r\n        l = len(num)\r\n        for i in range(l-1):\r\n            for j in range(i+1,l):\r\n                if num[i]>num[j]:\r\n                    num[i],num[j] = num[j],num[i]\r\n    \r\n        return num\r\n\r\n> 所有元素逐个比较，大的元素或者小的元素，不停的上浮，俗称冒泡。\r\n\r\n- 时间复杂度O(n^2)\r\n- 稳定排序\r\n- 可用于链式存储结构\r\n- 移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序,n较大时，此算法不宜采用\r\n\r\n\r\n### 快速排序\r\n\r\n    def quick_sort_1(num):\r\n\r\n        if len(num)<2:\r\n            return num\r\n    \r\n        left,right = [],[]\r\n        mid = num[0]\r\n        num = num[1:]\r\n    \r\n        for i in num:\r\n            if i>mid:\r\n                right.append(i)\r\n            else:\r\n                left.append(i)\r\n        return quick_sort_1(left)+[mid]+quick_sort_1(right)\r\n        \r\n> 找一个基准值，当前数组内的所有元素与基准值比较，大的放右边，小的放左边。递归求解，直到数组大小小于2.\r\n\r\n- 时间复杂度O(nlog2^n)\r\n- 优点：当n较大的时候，快速排序是所有内部排序方法最快的。\r\n- 缺点：记录非顺序的移动导致排序方法不稳定\r\n排序过程中需要定位表的下界和上界，所以适用于顺序结构，很难用于链式结构\r\n\r\n\r\n### 归并排序\r\n\r\n\r\n    def mergeSort(num):\r\n\r\n        L = len(num)\r\n        if L<2:\r\n            return num\r\n        mid = L//2\r\n    \r\n        left = mergeSort(num[:mid])\r\n        right = mergeSort(num[mid:])\r\n    \r\n        result = []\r\n        while left and right:\r\n            if left[0]<right[0]:\r\n                result.append(left.pop(0))\r\n            else:\r\n                result.append(right.pop(0))\r\n    \r\n        if left:\r\n            result += left\r\n        if right:\r\n            result += right\r\n    \r\n        return result\r\n> 同样递归求解，递归的把当前数组一分为二，直到数组不能继续拆分，即数组大小小于2。把分开的左右数组分别从第一个逐个比较，小的加入目标数组。\r\n\r\n- 每次合并操作的平均复杂度为O(n),二叉树深度为log2^n，时间复杂度O(nlog2^n)\r\n- 稳定排序，可用于链式结构。','2021-03-11 16:15:51.329267','2023-12-23 15:54:02.377857','几种常见的内部排序',48,9),(25,'二叉树构造，建立，遍历','## 二叉树的构造，建立，层次遍历，前中后序遍历\r\n\r\n> 刷leetcode题遇到很多二叉树的题，想着不如自己实现一下二叉树，以后写类似的题也方便。其中层次遍历为BFS，前中后序遍历为DFS\r\n\r\n\r\n        \r\n        class BinaryTree:\r\n            def __init__(self,val):\r\n                self.val = val\r\n                self.left = None\r\n                self.right = None\r\n\r\n            def __str__(self):\r\n                return f\"<val:{self.val},left:{self.left},right:{self.right}>\"\r\n        \r\n        \r\n        \r\n\r\n        from data_structure import BinaryTree\r\n        list = [1,2,3,4,5,6,7]\r\n        print(f\"list : {list}\")\r\n        \r\n        # 建立二叉树\r\n        def set_BinaryTree(list):\r\n            if not list:\r\n                return []\r\n        \r\n            temp = []\r\n            root = BinaryTree(list.pop(0))\r\n            mm = root\r\n            temp.append(root)\r\n        \r\n            while list:\r\n                for _ in range(len(temp)):\r\n                    root = temp.pop(0)\r\n                    # poplist前首先判断，若list已经为空，直接返回根节点mm\r\n                    if list:\r\n                        t = list.pop(0)\r\n                    else:\r\n                        return mm\r\n                    left = BinaryTree(t)\r\n                    root.left = left\r\n                    temp.append(root.left)\r\n                    \r\n                    # poplist前首先判断，若list已经为空，直接返回根节点mm\r\n                    if list:\r\n                        t1 = list.pop(0)\r\n                    else:\r\n                        return mm\r\n                    right = BinaryTree(t1)\r\n                    root.right = right\r\n                    temp.append(root.right)\r\n        \r\n            return mm\r\n        \r\n        tree = set_BinaryTree(list)\r\n        print(f\"list转换为二叉树 : {tree}\")\r\n        \r\n        # 层次遍历二叉树\r\n        def bfs_tree(root):\r\n            if not root:\r\n                return []\r\n            list = []\r\n            vals = []\r\n        \r\n            list.append(root)\r\n            vals.append([root.val])\r\n        \r\n            while list:\r\n                temp = []\r\n                for _ in range(len(list)):\r\n        \r\n                    root = list.pop(0)\r\n                    if root.left:\r\n                        list.append(root.left)\r\n                        temp.append(root.left.val)\r\n        \r\n                    if root.right:\r\n                        list.append(root.right)\r\n                        temp.append(root.right.val)\r\n                if temp:\r\n                    vals.append(temp)\r\n            return vals\r\n        \r\n        m = bfs_tree(tree)\r\n        print(f\"层次遍历二叉树,每一行嵌套list : {m}\")\r\n        \r\n        # 前序遍历二叉树(深度优先DFS)\r\n        def pre_order_traversal(root):\r\n        \r\n            if not root:\r\n                return []\r\n            vals = []\r\n            def dfs(root):\r\n                if not root:\r\n                    return\r\n        \r\n                vals.append(root.val)\r\n                dfs(root.left)\r\n                dfs(root.right)\r\n        \r\n            dfs(root)\r\n            return vals\r\n        \r\n        pre_or = pre_order_traversal(tree)\r\n        print(f\"前序遍历二叉树 : {pre_or}\")\r\n        \r\n        \r\n        # 中遍历二叉树(深度优先DFS)\r\n        def InOrdeTraversal(root):\r\n        \r\n            if not root:\r\n                return []\r\n            vals = []\r\n            def dfs(root):\r\n                if not root:\r\n                    return\r\n        \r\n                dfs(root.left)\r\n                vals.append(root.val)\r\n                dfs(root.right)\r\n        \r\n            dfs(root)\r\n            return vals\r\n        \r\n        in_or = InOrdeTraversal(tree)\r\n        print(f\"中续遍历二叉树 : {in_or}\")\r\n        \r\n        \r\n        # 后序遍历二叉树(深度优先DFS)\r\n        def PostOrderTraversal(root):\r\n        \r\n            if not root:\r\n                return []\r\n            vals = []\r\n            def dfs(root):\r\n                if not root:\r\n                    return\r\n        \r\n                dfs(root.left)\r\n                dfs(root.right)\r\n                vals.append(root.val)\r\n        \r\n            dfs(root)\r\n            return vals\r\n        \r\n        po_or = PostOrderTraversal(tree)\r\n        print(f\"后序遍历二叉树 : {po_or}\")\r\n        \r\n        \r\n        \"\"\"\r\n        list : [1, 2, 3, 4, 5, 6, 7]\r\n        list转换为二叉树 : <val:1,left:<val:2,left:<val:4,left:None,right:None>,right:<val:5,left:None,right:None>>,right:<val:3,left:<val:6,left:None,right:None>,right:<val:7,left:None,right:None>>>\r\n        层次遍历二叉树,每一行嵌套list : [[1], [2, 3], [4, 5, 6, 7]]\r\n        前序遍历二叉树 : [1, 2, 4, 5, 3, 6, 7]\r\n        中续遍历二叉树 : [4, 2, 5, 1, 6, 3, 7]\r\n        后序遍历二叉树 : [4, 5, 2, 6, 7, 3, 1]\r\n        \"\"\"','2021-03-11 16:16:59.175173','2023-12-23 15:54:02.422251','二叉树的层次遍历，前中后序遍历',20,9),(26,'java-集合','> equals比较两个对象的值是否相等,若值相等，则hanshcode()的返回值也相等\r\n\r\n> == 比较两个对象是否是同一个对象\r\n        \r\n        \r\n        - List \r\n          - add(E e)             末尾添加元素\r\n          - add(int index,E e)   指定索引处添加元素\r\n          - remove(int index)    删除指定索引的元素\r\n          - remove(e)            删除元素e\r\n          - E get(int index)     获取指定索引的元素\r\n          - int size()                     获取链表大小\r\n          - ArrayList 数组实现\r\n          - LinkedList 链表实现\r\n        - Map(字典)\r\n          - HashMap key值无序\r\n          - TreeMap key有序，但是放入的key必须实现Comparable接口，如(String,Integer)\r\n          - EnumMap 枚举字典，性能优异。\r\n         \r\n        \r\n        - Set(对Map的简单封装，省去value)\r\n          - Hashset\r\n          - Treeset 有序\r\n        \r\n         \r\n        - Queue(队列)\r\n          - int size()  获取队列长度\r\n          - boolean add(E)/offer(E)   添加元素到队尾\r\n          - E remove()/poll   获取队首元素并删除\r\n          - E element()/peek()  获取队首元素并不从队列中删除\r\n        > 其中add,remove,element会抛出错误(throw Exception),offer,poll,peek会返回false或者null(所以不要把null添加到队列中，因为调用poll()方法时，很难确定取到的是null元素还是队列为空)\r\n        \r\n        - PriorityQueue  优先队列\r\n        - Deque  双端队列，继承Queue,并对其进行扩展\r\n        - Stack   由Deque实现\r\n          - 元素压栈 push()/addFirst()\r\n          - 元素出栈并弹出 pop()/removeFirst()\r\n          - 出栈但是不弹出 peek()/peekFirst()\r\n        \r\n        \r\n        - Collections JDK提供的工具类，位于java.util包中\r\n          - Collection.sort()对可变集合排序\r\n          - COllection.shuffle()打乱内部元素的顺序','2021-03-11 16:21:44.321810','2023-12-23 15:54:02.456866','java-集合',26,10),(27,'javascript中的in运算符','- 判断对象是否是数组的元素\r\n- 判断对象是否是集合的属性\r\n- 迭代,这里值得注意的是迭代出来的是索引，要想访问元素，需要list[index]访问\r\n\r\n\r\n        var list = [1,2,3,4,5,6,7];\r\n        console.log(1 in list);  // true\r\n        for (i in list){\r\n            console.log(list[i])    // 1,2,3........\r\n        }\r\n        \r\n        var obj = {\r\n            name: \"xx\",\r\n            age: 10\r\n        }\r\n        console.log(\"name\" in obj); // true\r\n    \r\n    \r\n- 唯独字符串不能用 in 运算符求\r\n\r\n\r\n        var s = \'s\';\r\n        var ss = \'as\';\r\n        console.log(s in ss);\r\n        \r\n        // TypeError: Cannot use \'in\' operator to search for \'s\' in as\r\n \r\n   \r\n求指定字符是否在字符串中要用\r\n1. indexOf()   返回字符在字符串中第一次出现的位置,若不存在返回-1\r\n2. search()    同理。','2021-03-11 16:22:17.404671','2023-12-23 15:54:02.529390','js 中的 in 运算符',23,11),(28,'Vue子组件和父组件的相互传值','### 父组件向子组件传值\r\n\r\n1. 通过:name 向子组件传递变量，子组件通过props接收\r\n\r\n\r\n        <div id=\"app2\">\r\n            // 遍历peoplelist\r\n            <mycomp v-for=\"i in peoplelist\"\r\n                    // 变量传给people\r\n                    :people=\"i\"\r\n                    :key=\"i\"\r\n                    //sel传递给父组件的parent函数\r\n            （3） @sel=\"parent\"></mycomp>\r\n            <h1>{{list1}}</h1>\r\n        </div>\r\n\r\n    \r\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\r\n        <script>\r\n            Vue.component(\'mycomp\',{\r\n                // props接收people\r\n                props:[\'people\'],\r\n                template:\'<di v>\' +\r\n                    // 调用people变量\r\n                    \'<h1>{{people}}</h1>\' +\r\n                   （1） // 点击\"选择\"触发函数cel\r\n                    \'<button @click=\"cel(people)\">选择</button></div>\', \r\n                methods:{\r\n                    cel:function (people) {\r\n                        // 函数cel监听事件，并传递给sel,people为参数值\r\n                      （2）  this.$emit(\'sel\',people)   \r\n                    }\r\n                }\r\n            })\r\n            \r\n            let app = new Vue({\r\n                el:\'#app2\',\r\n                data:{\r\n                    peoplelist:[\'小明\',\'小张\',\'小何\'],\r\n                    list1:[\"xx\"]\r\n                },\r\n                methods:{\r\n                    //  主逻辑函数，接收people,push到list1\r\n             (4)        parent:function (people) {\r\n                        this.list1.push(people);\r\n                    }\r\n                }\r\n        \r\n            })\r\n        </script>\r\n        \r\n### 通过子组件向父组件传值\r\n\r\n1. 通过$emit监听事件\r\n\r\n\r\n\r\n        <div id=\"app2\">\r\n            <mycomp v-for=\"i in peoplelist\"\r\n                    :people=\"i\"\r\n                    :key=\"i\"\r\n                    //sel传递给父组件的parent函数\r\n            （3） @sel=\"parent\"></mycomp>\r\n            <h1>{{list1}}</h1>\r\n        </div>\r\n\r\n    \r\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\r\n        <script>\r\n            Vue.component(\'mycomp\',{\r\n                props:[\'people\'],\r\n                template:\'<div>\' +\r\n                    \'<h1>{{people}}</h1>\' +\r\n                   （1） // 点击\"选择\"触发函数cel\r\n                    \'<button @click=\"cel(people)\">选择</button></div>\', \r\n                methods:{\r\n                    cel:function (people) {\r\n                        // 函数cel监听事件，并传递给sel,people为参数值\r\n                      （2）  this.$emit(\'sel\',people)   \r\n                    }\r\n                }\r\n            })\r\n            \r\n            let app = new Vue({\r\n                el:\'#app2\',\r\n                data:{\r\n                    peoplelist:[\'小明\',\'小张\',\'小何\'],\r\n                    list1:[\"xx\"]\r\n                },\r\n                methods:{\r\n                    //  主逻辑函数，接收people,push到list1\r\n             (4)        parent:function (people) {\r\n                        this.list1.push(people);\r\n                    }\r\n                }\r\n        \r\n            })\r\n        </script>','2021-03-11 16:23:12.693347','2023-12-23 15:54:02.464781','Vue中父组件与子组件的相互传值',24,12),(29,'数据库索引','> 面试了两次，都问到了数据库索引，答的都差强人意。经过两天的时间，翻阅众多书籍，查看众多博客后，写下这篇文章。\r\n\r\n\r\n\r\n- 数据库索引以两种数据结构存储\r\n  - B-树(B+树)\r\n  - 哈希表\r\n\r\n- 非聚簇索引(以MyISAM引擎为例)(数据行有col1,col2个数据，col1为主键)\r\n    - 数据按照插入顺序在磁盘中放置\r\n    - 用col2建立索引，叶子节点存储行指针，根据所索引查找到行指针找到数据行。\r\n    - 主键索引与非主键索引并无区别\r\n    \r\n- 聚簇索引(以InnoDB为例)(数据行有col1,col2个数据，col1为主键)\r\n    - 数据库引擎自动以主键为关键字维护一个B树，数据以主键为基准，是有序的。\r\n    - 用col2建立索引，叶子节点存储的是主键值，这样的策略减少了当行移动或者数据页分裂时二级索引(以col2为关键字建立的索引)的维护工作。使用主键值会让二级索引占据更多的空间，换来的好处是，InnoDB在移动行时无需更新二级索引中的主键值。\r\n\r\n\r\n- 联合索引，(假设以a,b,c)建立索引\r\n    - 联合索引必须以建立索引时的顺序挨个使用，否则无法命中索引(最左原则)。这是因为按照联合索引建立B树的时候，以a为主要基准建立B树，若两行数据的a相同，则按照b排序，若两行数据的b也相同，则按照c排序。\r\n    - 比如a,ab,abc都可以命中索引，b,c,bc,ac都无法命中索引\r\n\r\n- 索引不命中的情况\r\n    - 使用不等于查询,\r\n    - 列参与了数学运算或者函数\r\n    - 在字符串like时左边是通配符.类似于\'%aaa\'.(也是因为最左原则，索引是按照字符串首字符为主要基准排序的，通配符放到最左边，首字符都没，无法查找)\r\n    - 当mysql分析全表扫描比使用索引快的时候不使用索引.\r\n    - 当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.\r\n\r\n- 覆盖索引\r\n    - 在二级索引中，如果叶子项中没有所要查找的数据，往往需要回表查询，这是额外的开销。\r\n    - 覆盖索引就是所要查找的数据已经在索引的叶子项中，无需再拿着主键到二次回表查询，速度很快。\r\n\r\n\r\n\r\n- 索引建立规则      \r\n  - 尽量用常见的查找关键字建立索引。\r\n  - 不要建立过多的索引，影响性能\r\n\r\n- B-树 一个平衡树，数据在叶子节点，查找次数取决于树的深度，对数级别的复杂度。\r\n- 哈希表 关键字作为参数传入哈希函数，哈希函数直接算出地址，直接访问，简单暴力。','2021-03-11 16:25:06.360503','2023-12-23 15:54:02.452764','数据库表以何种数据结构存储？索引所用在哪？索引又以何种数据结构存储？',48,13),(30,'redis入门操作','下载解压 make   进入daemonize 修改为yes 表示后台启动\r\n\r\n\r\nredis解压完进入/usr/local/bin   \r\n\r\n1. redis-server redis.conf    指定配置文件启动\r\n\r\nredis客户端连接\r\n2. redis-cli -p 6379    客户端指定端口启动\r\n\r\n3.shutdown  关闭redis   注意！第一步必须是 sudo redis-server redis.conf 否则没有权限 \r\n\r\n\r\n\r\n## 基本操作\r\n\r\nselect 3   切换数据库到3\r\n\r\ndbsize  数据库大小\r\n\r\nkeys *   所有建\r\n\r\nflushdb 清除当前数据库\r\n\r\nflushall 清除所有数据库的所有内容\r\n\r\n\r\nexists name 查看name是否存在，若存在，返回1，反之为0\r\n\r\nexpire name 5   五秒后name过期，自动删除\r\n\r\nttl name 查看name多久到期   返回一个的到期数值，已经到期返回-2\r\n\r\ntype name 查看name的数据类型\r\n\r\n## String\r\n\r\n- 使用场景\r\n    - 计数器\r\n    - 统计多单位的数量\r\n    - 粉丝数\r\n    - 对象缓存存储\r\n\r\nappend name abc 把字符串附加到name后边,如果name不存在，相当于set name abc\r\n\r\nstrlen name 返回key name的字符串的长度\r\n\r\ngetrange name 0 3 获得0，1，2，3四个字符组成的字符串       \r\ngetrange name 0 -1 相当于getname             \r\nsetrange name 0 jkl 从0开始依次替换jkl                 \r\n\r\nsetex key1 10 \"hello\"   设置key1为\"hello\" 10m后到期\r\n\r\nsetnx key2 11  如果key2不存在，设置key2为1\r\n\r\ngetset key value 得到第一个key的值，然后把key设置为value\r\n\r\n## List   底层数据结构为双向链表\r\n\r\n- 消息队列\r\n- 栈\r\n\r\nlpush list 1  在列表list头部插入1   l 代表left           \r\nrpush list 2  在列表list尾部插入2   r 代表right  \r\n\r\nlpop list  从最左边拿一个值                       \r\nrpop list 同理，从最右边             \r\n\r\nlrange list 0 1  获取列表list区间0到1的值                   \r\nlrange list 0 -1 获取整个list的值                  \r\n\r\nlindex list 0 根据索引获得list获得第1个值\r\n\r\nllen list 获得list的长度\r\n\r\nlrem list 1 one  从list里边移除一个one值，如果存在多个相同的one,移除从左开始第一个   \r\n\r\nltrim list 0 2   获得list的0，1，2三个值   \r\n\r\nrpoplpush lsit1 list2  从list1里边拿出来最右边的值  添加到list2的最左边    \r\n\r\nlset list 2 22 把list中索引为2的值更换22，如果索引2不存在，报错\r\n\r\nlinsert list before|after one two 在列表list,值为one的前边或者后边插入值two \r\n\r\n## Set  无序不重复\r\n\r\nsadd set 1  向set中添加值1    \r\nsadd set 2   添加2    \r\n\r\nspop set  随机弹出一个值\r\n\r\nsismember set 3 查看3是否在集合set中，存在则返回1，否则返回0\r\n\r\nscard set 获得集合set的值的个数    \r\n\r\n\r\nsrandmember set 1  从集合set中随机获得1个值    \r\nsrandmember set 2  随机获得两个值\r\n\r\nsmove set1 set2 one 把set1中的值one移动到set2中\r\n\r\nsdiff set1 set2 返回在set1但不在set2的元素\r\n\r\nsinter set1 set2 交集             \r\nsunion set1 set2 并集\r\n\r\n\r\n## Hash(哈希)\r\n\r\nMap集合  key-<map>\r\n\r\n\r\nhset hash k1 v1  在哈希表hash中存放key为k1,值为v1    \r\nhmset hash k2 v2 k3 v3   一次设置多个键值对   \r\n\r\nhget hash k1 在哈希表hash中获得键为k1的值\r\nhmget hash k1 k2 k3  一次获得多个值\r\n\r\nhgetall hash 获得hash表中的所有键值对\r\n\r\nhkeys hash 获得所有键             \r\nhvals hash 获得所有值\r\n\r\nhdel hash v1 删除哈希表hash中键为v1的键值对     \r\n\r\nhlen hash 获得hash表的长度\r\n\r\nhexists hash k1  判断hash表中是否存在键k1\r\n\r\nhincrby hash age 2   哈希表hash中的值age加二        \r\nhincrbyfloat hash age 0.1   加零点一   \r\nhincrby hash age -1   哈希表hash中的值age减二\r\n\r\n\r\nhsetnx hash age 10  如果hash不存在，创建\r\n\r\n\r\n## Zset 有序集合\r\n\r\n\r\nzadd source 90 zhi     在有序集合source中插入zhi,分数是90，这个分数是排序关键字               \r\nzadd source 60 yang\r\n\r\nzrem source yang 移除指定的key\r\n\r\n#### 按照分数值正序，从小到大,按照索引\r\nzrange source 0 2   获得索引0到2的关键字    \r\nzrange source 0 2 withscores   获得分数值和关键字    \r\nzrange source -3 -1 获得从倒数第三个元素到倒数第一个元素\r\n#### 逆序，从大到小，按照索引\r\nzrevrange source 1 2   \r\nzrevrange source -2 -1 \r\n\r\n#### 正序，按照分数值\r\nzrangebyscore source -inf +inf 分数排序  获得从负无穷到正无穷的值   zrangebyscore source  -10 100  分数值-10到100\r\n\r\nzcount source 60 100 获得分数60到100的个数\r\n\r\n\r\n\r\n## 地理空间(geospatial)\r\n\r\n## HyperLogLog`\r\n\r\n统计一个页面有多少用户点击，一个用户多次点击，算一次。如果通过set等，hashmap等数据结构，占用内存数量必然和用户数成正比，当用户数量大的时候，占用大量内存是不可接受的。\r\n\r\n但是HyperLogLog只需12K内存就可以统计2*64个数据。这是用精确度换空间\r\n\r\n伯努利实验可以根据k_max估算n。那么我们可以吧每个用户id哈希为一个比特串\r\n，必然会至少出现一次1的位置。把每一个比特串为一次伯努利实验。\r\n\r\n\r\npfadd key1 a b c    key1中添加元素    \r\npfadd key2 c m n    key2中添加元素\r\n\r\n\r\npfcount key1 获得key1的元素个数\r\n\r\npfmerge key key1 key2 把key1和key2合并到key中，求并集\r\n\r\n#### bitmap \r\n   \r\n用位数表示仅有状态的两个数据    \r\n如           \r\nsetbit day 1 0    设置key为day，第一天为0，表示阴天      \r\nsetbit day 2 1    第一天为1，表示晴天\r\nsetbit day 3 1   \r\ngetbit day 2      得到key为day第二天的值\r\n\r\nbitcount day 得到值为1的个数\r\n\r\n\r\n#### 事务\r\n\r\nredis没有隔离级别的概念。            \r\n\r\nredis单条命令式保持原子性，但是事务不保证原子性\r\n\r\nmulti 开启事务  但不执行\r\n\r\nexec 执行事务\r\ndiscard 放弃事务  \r\n\r\n\r\n事务中命令错误，所有的命令都不会被执行    \r\n如果运行时错误，比如给字符串自增1  那么这个命令不执行，事务中的其他语句继续执行\r\n\r\n#### 乐观锁\r\n\r\n使用watch可以当做redis的乐观锁操作\r\nwatch key 给key加锁            \r\nunwatch 解锁\r\n\r\n**线程1**          \r\nset money 100   \r\nwatch money   监视money对象      \r\n\r\nmulti      开启事务        \r\ndecrby money 20  修改money值    \r\n这里事务还没有执行\r\n\r\n\r\n**线程2**\r\n\r\nset money 1000   在线程1事务没有执行的情况下，修改money\r\n\r\n\r\n**线程1**\r\n\r\nexec    执行失败 \r\n(nil) \r\n\r\n### 性能测试\r\n\r\nredis-benchmark -h loaclhost -p 6379 -c 100 -n 100000\r\n\r\n-h 主机  -p 端口 -c 并发量  -n 请求数\r\n\r\n\r\n100000 requests completed in 0.84 seconds   请求数   总用时               \r\n100 parallel clients    100并发           \r\n3 bytes payload    每次写入三个字符          \r\nkeep alive: 1     一个连接            \r\nhost configuration \"save\": 900 1 300 10 60 10000                \r\nhost configuration \"appendonly\": no                 \r\nmulti-thread: no               \r\n\r\n98.60% <= 1 milliseconds              \r\n99.82% <= 2 milliseconds             \r\n100.00% <= 2 milliseconds             \r\n118483.41 requests per second      每秒的请求数','2021-03-11 16:25:56.449606','2023-12-23 15:54:02.460827','redis入门操作指令',30,13),(31,'redis持久化','## RDB\r\n\r\n父进程fork一个子进程，子进程进行持久化操作，子进程先将数据写入到一个临时的文件，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程，主进程不进行I/O操作。这保证了极高的性能。在需要大规模数据的回复，且对于数据恢复的完整性不是非常敏感的情况下，RDB要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。redis持久化默认RDB，一般不需要进行配置。\r\n\r\nrdb文件默认保存在dump.db\r\n\r\n\r\n- rdb触发规则\r\n    - save的规则满足的情况下，会自动触发rdb规则\r\n    - 执行flushall命令，也会触发rdb文件\r\n    - 退出redis,也会产生rdb文件\r\n\r\n\r\n- 恢复rdb文件\r\n    - 将rdb文件放到redis启动目录，redis启动时自动检查dump.rdb恢复其中的数据\r\n    - 查看需要存在的位置 config get dir ---->   /usr/local/bin\r\n\r\n\r\n**优点**\r\n\r\n1. 适合大规模的数据恢复\r\n2. 对数据的完整性要求不高\r\n\r\n\r\n**缺点**\r\n\r\n1. 需要一定的时间间隔进行操作，如果redis意外宕机，最后一次修改的数据就没有了\r\n2. 需要一个额外进程进程持久化操作，消耗内存空间\r\n\r\n\r\n## AOF\r\n\r\n默认不开启。需要手动将appendonly改为yes开启。然后重启redis\r\n\r\n把所有修改数据库的操作都记录下来，恢复的时候再执行一遍\r\n\r\n如果aof文件有错位，这时候redis启动会失败，需要修复aof文件\r\n\r\n用redis工具  redis-check-aof --fix   *.aof修复\r\n\r\nappendonly no  默认是不开启aof模式的，默认是使用rdb方式持久化的                  \r\nappendfilename  \"appendonly.aof\"    持久化的文件名字          \r\n\r\nappendfsync always 每次修改都会sync,消耗性能             \r\nappendfsync everysec 每秒执行一次sync,可能会丢失者1s的数据             \r\n \r\nappendfsync no  不执行sync,这个时候操作系统自己同步数据，速度最快         \r\n\r\n**优点**\r\n\r\n1. 每一次修改同步，文件完整性更好\r\n2. 从不同步，效率最高\r\n\r\n**缺点**\r\n\r\n1. 相对与数据文件来说，aof远远大于rdb,修复的速度也比rdb慢！\r\n2. aof运行效率不如rdb','2021-03-11 16:26:30.933810','2023-12-23 15:54:02.438059','redis RDB和AOF持久化',51,13),(32,'TCP三次握手，四次挥手','## TCP的连接管理\r\n> TCP是面向连接的协议。连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此，TCP连接就有三个阶段，即连接建立，数据传输和连接释放。建立连接的目的就是为接下来要进行的通信做好充分的准备工作，其中最重要的就是分配相应的资源。在通信结束以后显然要释放所占用的资源，即释放连接。TCP的连接是运输层的连接，只存在于通信的两个端系统中，而网络核心的路由器完全不知道它的存在。\r\n\r\n### TCP的连接建立\r\n\r\n- 在连接建立的过程中要解决一下三个问题：\r\n    - 要使每一方能够确知对方的存在\r\n    - 要允许双方协商一些参数(如最大报文段长度，最大窗口大小，服务质量等)\r\n    - 能够对运输实体资源(如缓存大小，各状态量，连接表中的项目等)进行分配和初始化\r\n\r\n[![05Weyj.md.jpg](https://s1.ax1x.com/2020/10/14/05Weyj.md.jpg)](https://imgchr.com/i/05Weyj)\r\n\r\n- 三次握手：假设存在两个主机（A,B）。A是客户端进程，B是服务器进程。A和B建立连接。\r\n    1. A的TCP向主机B的TCP发出连接请求报文段，其首部中的同步位SYN应置1，同时选择一个序号seq=x,这表明下一个报文段的第一个数据字节的序号是x+1。\r\n    2. 主机B的TCP收到请求报文后，如同意，则发回连接请求确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1,同时也为自己选择一个序号seq=y。\r\n    3. 主机A的TCP收到B接受请求的确认后，还要向B给出确认，其ACK置1，确认号ack=y+1,而自己的序号seq=x+1.\r\n\r\n\r\n-  为什么要三次握手，而不是两次呢？这主要是为了防止已经失效的连接请求报文段突然又传送到了主机B，因而导致错误产生。“已失效的连接请求报文段”是这样产生的。\r\n    - 情况1，主机A发出连接请求，但因连接请求报丢失而未收到确认。主机A于是又传一次。后来收到了确认，建立连接。这里主机共发送了两个连接请求报文段，其中的第二个到达了主机B。\r\n    - 情况2，主机A发出的第一个请求报文段并没有丢失，而是在某些网络节点滞留时间太长，主机A久久收不到B的确认报文段，于是重发，第二次主机A的报文段到达了B，B发送确认报文段，建立连接。在连接释放后，B这时才收到A的第一个延误的报文段，误以为是主机A又发出的一次新的连接请求，于是向A发送确认报文段，同意建立连接。主机A由于并没有要求建立连接，因为不理睬B主机，也不向B主机发送数据，但B主机却以为连接就这样建立了，并一直等待主机A发来数据，主机B的许多资源就浪费了。\r\n\r\n\r\n> 三次握手的办法可以防止上述现象的发生。例如，在情况2，主机A不向B发出确认，主机B收不到确认，连接就建立不起来\r\n\r\n\r\n- 第三次握手失败怎么办？\r\n\r\n**Server 端**\r\n\r\n第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。\r\n\r\n而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.\r\n\r\n如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。\r\n\r\n\r\n**Client 端**\r\n\r\n在linux c 中，client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。\r\n\r\n\r\n\r\n\r\n\r\n### TCP的连接释放\r\n\r\n- 在数据传输结束后，通信的双方都可以发出释放连接的请求。在连接释放的过程中要释放为该连接分配的所有资源\r\n\r\n\r\n\r\n[![05WmOs.md.jpg](https://s1.ax1x.com/2020/10/14/05WmOs.md.jpg)](https://imgchr.com/i/05WmOs)\r\n\r\n\r\n- 四次挥手\r\n    1. 主机A的应用进程先向其TCP发出连接释放的请求，并且不再发送数据(但可以发送确认，可以接受数据)。TCP通知对方(主机B)要释放从A到B这个方向的连接。\r\n    2. 主机B的TCP收到释放连接通知后即发出确认。主机B的TCP这时应通知高层应用进程。如上图(1).。这样，从A到B的连接就释放了，连接处于半关闭状态。相当于A告诉B，我已经没有数据要发送了，但是如果你还要发送数据，我仍可以接收。\r\n    3. 若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接，并向A发出释放连接通知，见上图(2)。\r\n    4. 此时主机A必须对此发出确认。这时才把B到A的反方向连接释放掉。但此时主机A的TCP并不能马上释放连接，还要再等待一个超时时间才能将整个连接释放。因为A的确认报文可能不能到达B，B会重传步骤3报文段，在这段超时时间内，若A又收到B重传的报文段，需要再次确认。收到A的确认报文段后，B才能最终将整个连接释放。若等待的这段超时时间内没有收到B的报文段，说明B已经收到A的确认，此时主机A的TCP则向应用进程报告，整个连接已经全部释放','2021-03-11 16:27:28.066548','2023-12-23 15:54:02.397639','详细描述三次握手四次挥手的经过，以及原因',53,14),(33,'拥塞控制','> 当网络中出现太多的分组时，网络的性能开始下降。这种情况称为拥塞。拥塞是分组交换网中一个非常重要的问题。如果网络中的负载，即发送到网络中的数据量超过了网络的容量，即网络中能处理的数据量，那么网络中就可能发生拥塞。所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载\r\n\r\n### 拥塞的控制与危害\r\n\r\n[![BVaP1O.png](https://s1.ax1x.com/2020/10/24/BVaP1O.png)](https://imgchr.com/i/BVaP1O)\r\n\r\n如图，理想情况下，在吞吐量饱和前，网络吞吐量等于输入负载，故吞吐量曲线时45度的斜线。当输入载荷超过网络容量时(由于网络资源的限制)，在理想情况下，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这表明输入负载中一部分损失掉了。(如，输入到网络中的某些分组被路由器丢弃了)\r\n\r\n\r\n但在实际网络中，若不采取有效的拥塞控制手段，随着输入载荷的增大，网络吞吐量的增长率会逐渐减小，特别时当输入负载达到某一数值时，网络的负载反而随着输入负载的增大而下降，这时网络进入拥塞状态。当输入负载继续增大，网络吞吐量甚至有可能下降为零，即死锁.\r\n\r\n那么为什么当输入负载达到某一数值时，网络的吞吐量反而下降呢？如图5-20，A，C发送速率都为100，因R1-R2为100Mbit/s,所以AC在R1处各损失50Mbit/s带宽。R2-D仅仅10Mbit/s，所以C在路由器R2会损失40Mbit/s带宽(C发送的分组在路由器R2排队等候向D转发时被丢弃了)。这时网络能达到的实际吞吐量只有60Mbit/s(A+B=50+10=60)。这就出现了网络拥塞所带来的典型问题，即网络性能变差，资源被浪费。出现该问题的本质原因是：C有大量分组在路由器R2处因网络拥塞被丢弃，虽然这些分组不能到达目的地，但却白白占用了其所经过链路的带宽和资源。由于这些无用分组占用资源，使得A无法使用这些资源和带宽，导致资源浪费。\r\n\r\n解决此问题的最终办法是控制发送速率，即限制输入到网络中的负载，比如此例子中，若A和C的发送速率分别为90和10，那么，该网络的吞吐量可达到100。\r\n\r\n### 拥塞控制的基本方法\r\n\r\n- 拥塞控制和流量控制的区别\r\n    - 拥塞控制和流量控制都是控制源点的发送速率。\r\n    - 拥塞控制的任务是防止过多的数据注入到网络中，使网络能够承受现有的网络负载。这是一个全局性的问题，涉及各个方面的行为，包括所有主机，路由器，路由器内部的存储转发处理过程。\r\n    - 流量控制只与特定点与点通信的发送方和接收方之间的流量有关。它的任务是防止发送方发送数据太快，超过接收方接受能力。流量控制通常涉及的做法是，接收方 向 发送方提供某种直接反馈，抑制发送方的发送速率\r\n\r\n\r\n- 拥塞控制\r\n    - 开环控制  开环控制试图用良好的设计来解决问题，它的本质是从一开始就保证问题不会发生。一旦系统运行起来，就不需要修正。由于因特网不提供资源预留机制，而且流量的特性不能准确描述，所以在因特网中拥塞控制主要采用闭环控制方法。\r\n    - 闭环控制  一种基反馈环路的方法，包括三个部分\r\n        - 检测网络系统以便检测到拥塞在何时，何地发生\r\n        - 把拥塞发生的信息传送到可以采取行动的地方\r\n        - 调整网络系统的运行以解决出现的问题\r\n\r\n\r\n- 闭环控制\r\n    - 显式反馈算法   从拥塞点(即路由器)向源点提供关于网络中拥塞状态的显式反馈信息，源点受到反馈信息应该降低发送速率。但是当网络拥塞发生时，向网络中注入这些额外的分组(拥塞点发送的显式反馈信息)可能火上浇油，因此在实际中很少使用。更好的显式反馈信息是，在路由器转发的分组中保留一个比特或者字段，来表示网络拥塞状态，而不是专门发送一个分组。\r\n    - 隐式反馈算法   源端通过对网络行为的观察(如分组丢失与往返时间)来推断网络是否发生拥塞，无需拥塞点提供显式反馈信息。**TCP就是隐式反馈算法**。\r\n\r\n\r\n### TCP的拥塞控制\r\n\r\n\r\n> TCP采用的方法是没一个发送方根据所感知到的网络拥塞程度，来限制其向连接发送流量的速率。如果TCP发送方感知到从它到目的地之间路径没有拥塞，则增加发送速率，反则降低发送速率。该方法要解决三个问题\r\n\r\n#### 1. TCP发送方如何限制它的发送速率？\r\n\r\nTCP的流量控制利用接收方通告给发送方的**接收窗口**大小来限制**发送窗口**的大小。这个窗口大小就是接收方发给发送方的TCP报文段首部中的窗口字段的值。实际TCP的发送方还维持个叫做**拥塞窗口**的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且是动态变化的。TCP发送方的窗口大小取决于接收方接收窗口和拥塞窗口的**最小值**。\r\n\r\n#### 2. TCP发送方如何知道网络发生了拥塞？\r\n\r\n当网络拥塞时，路由器会丢失分组。现在通信线路的传输质量很好，因传输出差错而丢弃分组的概率是很小的（远小于1%）。因此检测到分组丢失就可以认为网络出现了拥塞。根据快速**重传原理**可以知道。发送方不一定要通过重传计时器才能发现分组的丢失，**可以通过接收到三个重复确认就能判断有分组丢失(累计确认机制)**。因此，当重传计时器超时或者接收到三个重复确认时，TCP的发送方就认为网路发生了拥塞。\r\n\r\n#### 3. 采用什么算法改变其发送速率呢？\r\n\r\n1. 慢启动和拥塞避免\r\n\r\n[![BVaicD.png](https://s1.ax1x.com/2020/10/24/BVaicD.png)](https://imgchr.com/i/BVaicD)\r\n\r\n\r\n如果发送方在发送数据时，完全不知道网络的拥塞情况，如果立即把较大的发送窗口中的数据全部注入到网络中，那么有可能引起网络阻塞。所以拥塞窗口的值应从小(一个最大报文段MSS的数值)慢慢变大，直到拥塞，这个从小到大的过程是**指数**增长的，如（1,2,4,8）。慢启动是指一开始发送速率很慢(cwnd=1)，因为增大过程是指数级别的，所以会很快使网络到达拥塞状态。因此当网络要接近拥塞状态时，应该降低发送速率的增长速率，这可以使TCP连接在一端相当长的时间内保持较高的发送速率但是又不使网络阻塞。为此，TCP有一个状态变量，即**慢启动门限**。当发送窗口以指数增长到慢启动门限时，增长速率开始减慢(从**慢启动状态**进入**拥塞避免状态**)，以线性增长速率增长，即MSSx(MSS/cwnd)。\r\n\r\n\r\n[![BVaC9K.png](https://s1.ax1x.com/2020/10/24/BVaC9K.png)](https://imgchr.com/i/BVaC9K)\r\n\r\n\r\n当进入拥塞状态，发送方立即将拥塞窗口重新设置为1，重新进入慢启动状态，并把慢启动门限设置为拥塞时的发送窗口值的一半。这样做的原因是可以迅速减少主机发送到网络中的分组数，使路由去有足够时间把队列中的分组处理完毕，并且下次很有可能再次在该窗口值发生拥塞，所以当下次拥塞窗口又接近该值时，降低窗口的增长速率，进入拥塞避免阶段，使发送方可以长时间保持一个合理的发送速率。拥塞避免并不能避免拥塞，只是把拥塞窗口控制为线性增长，使网络不容易立即出现阻塞。\r\n\r\n2. 快速恢复\r\n\r\n\r\nTCP检测到分组丢失有两种情况：重传计时器超时和收到连续三个重复的ACK。\r\n\r\n当重传计时器超时，说明后续的分组都被丢弃了，一直没有收到确认，说明此时网络已经拥堵不堪，应立即将拥塞窗口设置为1。\r\n\r\n当发送方收到三个重复的ACK时，虽然有可能丢失了一些分组，但这三个确认表明丢失分组外的三个分组已经被接收，说明网络拥塞并不严重，这时候如果立即把拥塞窗口置为1，有点因噎废食的味道，这会导致发送方经过较长时间才能恢复到正常的传输速率。所以有了和**快速重传**对应的**快速恢复**算法。\r\n\r\n\r\n[![BVaph6.png](https://s1.ax1x.com/2020/10/24/BVaph6.png)](https://imgchr.com/i/BVaph6)\r\n\r\n- 快速恢复算法\r\n    1. 当发送方收到三个ACK时，将**慢启动门限**设置为当前发送窗口的一半(这一点与慢启动算法一样)\r\n    2. **拥塞窗口** 不设置为1，而是设置为**慢启动门限**，并开始执行拥塞避免算法,使拥塞窗口以较大的初始速度缓慢增长\r\n\r\n\r\n\r\n在很多文献中有“加性增”，“乘性减”的概念。乘性减即收到三个重复ACK，将拥塞窗口减半。加性增即从慢启动门限到拥塞时的状态。\r\n\r\n对于长时间的TCP链接，在稳定时拥塞窗口大小呈现锯齿状，如图\r\n\r\n\r\n[![BVUzA1.png](https://s1.ax1x.com/2020/10/24/BVUzA1.png)](https://imgchr.com/i/BVUzA1)','2021-03-11 16:28:13.734396','2023-12-23 15:54:02.401642','TCP拥塞控制，慢启动，拥塞避免，快速恢复',67,14),(34,'进程概述','### 进程的定义\r\n\r\n为什么要引入进程的概念？\r\n\r\n在早期未配置OS的系统和单批道处理系统中，程序是**顺序执行**的，程序具有**顺序性**(依次执行)，**封闭性**(程序独占全机资源，执行结果不受外界影响)，**可再现性**(数次运行，结果相同)，但是这种方式会浪费很多资源，系统运行效率低。为解决此问题，在系统中引入了**多道程序技术**，是程序或程序段可以并发执行,这提高了系统的吞吐率和资源利用率，但由于他们共享系统资源，以及他们为完成同一任务而相互合作，致使在这些并发执行的程序之间必将形成相互制约的关系，这时程序并发执行会由**间断性**，**失去封闭性**，**不可再现性**，这是致命的，这意味着相同输入可能带来不同的结果。\r\n\r\n为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了\"进程\"的概念\r\n\r\n为了使参与并发执行的每个程序(含数据)都能独立的运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block,PCB)。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。由程序段，相关的数据段和PCB三部分便构成了进程实体(又称进程映像)。一般情况下，进程实体简称进程。\r\n\r\n- 进程的特征\r\n    - 动态性: 进程的实质是进程实体的执行过程，因此，动态性就是进程的最基本的特征。\r\n    - 并发性: 进程可以同存内存中，可同时运行。\r\n    - 独立性: 进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位。 \r\n    - 异步性: 进程异步方式运行，按各自独立的，不可预知的速度向前推进。所以传统意义上的程序并发执行，结果是不可再现的，为了使程序在并发运行时，虽然具有异步性，但仍保证程序并发执行的结果可再现，引入了**进程**概念，并配置相应的进程同步机制。\r\n\r\n### 进程的基本状态及其转换\r\n- 进程的五种基本状态\r\n    - 创建状态 首先由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息，然后为该进程分配运行时所必须的资源，最后把该进程转入就绪状态插入就绪队列中。\r\n    - 就绪 进程已分配到除CPU外的所有资源，只要获得CPU即可执行，若多个进程皆处于就绪状态，按照一定的算法(如优先级，先来先到)排成队列，称该队列为就绪队列。\r\n    - 运行 已获得CPU，正在执行\r\n    - 阻塞 正在执行的进程由于发生某事件(如I/O,申请缓冲区失败，等待用户输入)暂时无法执行，让处理机，OS把处理机而分配给另一个就绪进程\r\n    - 终止状态 首先等待操作系统进程善后处理，然后将其PCB清零，并将PCB空间返还系统。\r\n    \r\n    [![BJ6MW9.png](https://s1.ax1x.com/2020/10/29/BJ6MW9.png)](https://imgchr.com/i/BJ6MW9)\r\n\r\n\r\n- 挂起操作和进程状态的转换\r\n\r\n\r\n除了上述基本的进程状态，为了系统和用户观察和分析的需要，引入了挂起操作。\r\n    \r\n这时进程状态间的转换\r\n\r\n\r\n[![BJ6QzR.png](https://s1.ax1x.com/2020/10/29/BJ6QzR.png)](https://imgchr.com/i/BJ6QzR)\r\n    \r\n### 进程控制\r\n\r\n> 通常将一些与硬件紧密相关的模块(如中断处理程序等),各种常用设备的驱动程序以及运行频率较高的模块(时钟管理，进程调度，许多模块所公用的一些基本操作)，都安排在紧靠硬件的软件层次中，将他们常驻内存，即通常被称为的**OS内核**，这样做一是便于对这些软件进行保护，防止遭受其他应用程序的破坏；而是可以提高OS的运行效率\r\n\r\n为防止OS本身及其关键数据如(PCB)遭到应用程序有意无意的破坏，通常将处理机的执行状态分为系统态和用户态\r\n\r\n- 系统态：又称管态，也称为内核态。具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行\r\n- 用户态：又称目态。具有较低特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区。一般情况下，应用程序只能在用户态运行，不能去执行OS指令以及访问OS区域，这样可以防止应用程序对OS的破坏。\r\n\r\n\r\n#### OS内核两大方面的功能:\r\n\r\n##### 支撑功能\r\n\r\n- **中断处理** 内核最基本的功能，是整个操作系统赖以活动的基础，OS中许多重要的活动，如系统调用，键盘命令的输入，进程调度，设备驱动等，都依赖中断处理。通常，为减少处理机中断的时间，提高并发性，内核在中断进行‘有限处理’后，便转入相关进程。\r\n- **时钟管理** 是内核的基本功能，OS中的许多活动都需要它的支撑，如在时间片轮转调度中，每当时间片用完时，便由时钟管理产生一个中断信号，促使调度程序重新进行调度。\r\n- **原语操作** ‘原子操作’如PV原语通过操作信号量来处理进程间的同步与互斥的问题。其核心就是一段不可分割不可中断的程序。\r\n\r\n\r\n##### 资源管理功能\r\n\r\n- **进程管理**  各个功能模块的运行频率较高，如进程调度，创建，撤销或者为多种功能模块所需要，如用于实现进程同步的原语，常用的进程通信原语等。通常将他们放在内核中，提高OS的性能。\r\n- **存储器管理** 逻辑地址和物理地址的转换，内存的分配回收等功能模块。放内核中，提高OS的性能\r\n- **设备管理** 驱动程序，用于缓和CPU与I/O速度不匹配矛盾的缓冲管理，用于实现设备分配和设备独立性的功能等','2021-03-11 16:28:43.243523','2023-12-23 15:54:02.407579','进程如何诞生的？如何工作的？',44,15),(35,'进程控制块详解','> 计算机操作系统对每个资源和每个进程都设置了一个数据结构，用于表征其实体，我们称之为资源信息表或进程信息表，其中包含了资源或进程的标识，描述，状态的等信息。OS管理的这些数据结构一般分为以下四类:内存表，设备表，文件表和用于进程管理的进程表，通常进程表又称为进程控制块PCB。这是着重介绍PCB。\r\n\r\n\r\n## 进程控制块PCB(Process Contral block)\r\n\r\nPCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息。\r\n\r\n- **进程控制块的作用**\r\n    - **作为独立运行基本单位的标志**\r\n系统是通过PCB感知进程的存在的，PCB是进程存在于系统中的唯一标志\r\n    - **能实现间断性运行方式** 系统可将CPU现场信息保存在被终端进程的PCB中，供该进程再次被调度执行时恢复CPU现场时使用。\r\n    - **提供进程管理所需要的信息** PCB中记录程序和数据在内存或外存中的始地址。可根据PCB中的资源清单了解到该进程所需的全部资源\r\n    - **提供进程调度所需要的信息**  当调度程序调度某进程运行时，只有就绪状态的进程才能被调度执行，PCB中提供了进程处于何种状态的信息\r\n    - **实现与其他进程的同步与通信** PCB中具有实现进程通信的区域或通信列指针\r\n\r\n- **进程控制块中的信息**\r\n    - **进程标识符** 唯一的标识一个进程\r\n    - **处理机状态** 处理机状态信息也称为处理机的上下文，主要处理由处理机的各种寄存器中的内容组成的。\r\n    - **进程调度信息**\r\n    - **进程控制信息**\r\n\r\n- 进程控制块的组织方式\r\n    - **线性方式** 将所有的PCB组织在一张线性表中，将首址存在专用区域中，每次查找需要扫描整表，适合进程数目不多的系统\r\n    - **链接方式** 为具有相同状态进程的PCB建立链表，如就绪队列，阻塞队列。\r\n    - **索引方式** 为具有相同状态的进程建立索引表，把各索引表在内存的首地址记录在内存的一些专用单元中','2021-03-11 16:29:16.650779','2023-12-23 15:54:02.391787','进程控制块PCB的作用',35,15),(36,'进程同步','### 进程同步\r\n\r\n- 同步机制应该遵循的规则\r\n    - 空闲让进   临界区处于空闲状态则进程可以进入临界区\r\n    - 忙则等待   不空闲就等待\r\n    - 有限等待   等待有限时间，不死等\r\n    - 让权等待   等待时，让出处理机，防止‘忙等’\r\n\r\n### 同步机制\r\n\r\n- 硬件同步机制\r\n    - 关中断\r\n    - 利用Test-and-Set指令实现互斥\r\n    - 利用Swap指令实现进程互斥\r\n\r\n- 信号量机制\r\n    - 整型信号量 wait(S)和signal(S)，这两个操作被称为P,V操作，是原子操作，在执行时不可中断。当一个进程在修改某信号量的时候，没有其他的线程可同时对该信号量进行修改\r\n    - 记录型信号量 整型信号量存在忙等。记录型信号量不存在此现象。记录行信号量维护一个值S->val表示资源数量，一个进程请求一个资源，则val-1,释放则val+1,当val<0,则把等待进程设为链表，排队等待。\r\n    - AND型信号量 当两个进程分别需要A,B两个资源，并且两个进程分别得到一个资源，然后等待自己没有拥有的那个资源，就会产生死锁。AND同步机制基本思想是将进程运行过程中所需要的所有资源，一次性全部分配给进程，等进程使用完后再释放。只要尚有一个资源未能分配给进程，其他所有的可能为之分配的资源也不分配给他。即对临界资源分配采用原子操作方式:要么把它请求的资源全部分配给进程，要么一个也不分配。\r\n    - 信号量集 上述几种信号量p,v操作都是对资源+1或者-1,当一个进程要同时需要N个资源时,需要N次wait(S),这是低效的甚至会引发死锁。信号量集可以一次对信号量-N。当所申请的资源数量低于一定值时，不予分配，反之一次分配完毕。\r\n\r\n- 管程机制 在信号量同步机制中，每个进程必须自备p,v同步操作，这使得大量的同步操作分布在各个进程中，增加系统的管理风险，可能因同步操作使用不当引起死锁。\r\n\r\n管程是一组操作的组合，类似面相对象，它在内部把数据，对数据的操作进行封装。进程对共享资源的申请和释放以及其他操作通过管程来完成。管程操作资源依然是p,v操作。','2021-03-11 16:29:48.909999','2023-12-23 15:54:02.386596','进程之前如何同步',55,15),(37,'单例模式的python实现','> 单例是一种设计模式，应用该模式的类只会生成一个实例。\r\n单例模式保证了在程序的不同位置都可以且仅可以取到同一个对象实例：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。因为单例是一个类，所以你也可以为其提供相应的操作方法，以便于对这个实例进行管理。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。\r\n\r\n\r\n- 函数装饰器实现\r\n\r\n\r\n        def f1(f):\r\n    \r\n            instance = None\r\n        \r\n            def inner(*args,**kwargs):\r\n                nonlocal instance\r\n        \r\n                if not instance:\r\n                    instance = f(*args,**kwargs)\r\n                return instance\r\n    \r\n        return inner\r\n    \r\n        @f1\r\n        class cls():\r\n            def __init__(self,num):\r\n                self.num = num\r\n        \r\n        c = cls(10)\r\n        \r\n        c1 = cls(10)\r\n        \r\n        print(id(c))\r\n        print(id(c1))\r\n\r\n\r\n- new关键字实现单例模式\r\n\r\n\r\n        class fun1():\r\n    \r\n            instance = None\r\n            def __new__(cls, *args, **kwargs):\r\n        \r\n                if not cls.instance:\r\n                    cls.instance = object.__new__(cls,*args,**kwargs)\r\n        \r\n                return cls.instance\r\n        \r\n            def __init__(self):\r\n                self.name = \'sss\'\r\n        \r\n            def f1(self):\r\n                return self.name\r\n        \r\n            s = fun1()\r\n            \r\n            print(id(s))\r\n            \r\n            s1 = fun1()\r\n            \r\n            print(id(s1))','2021-03-11 16:30:30.803094','2023-12-23 15:54:02.382827','基于函数装饰器和new私有方法的单例模式实现',52,16),(38,'五种IO模型详解','一般情况下，数据传输有两个阶段，即\r\n\r\n**1. 网卡--->内核**\r\n\r\n**2. 内核--->进程**\r\n\r\n\r\n无论进程阻塞在哪个阶段，我们都将其称为同步I/O，如果两个阶段进程都不阻塞，那么就是异步I/O。异步I/O依赖于操作系统的实现，比如linux的glibc aio和windows的IOCP。\r\n\r\n## 阻塞I/O\r\n\r\n阻塞I/O，顾名思义，当进程进行I/O操作的时候，进程是阻塞的，这也是最流行的I/O模式，代码编写简单，但是涉及多个I/O操作的时候，性能很差。\r\n\r\n[![6yGHJ0.md.png](https://s3.ax1x.com/2021/03/16/6yGHJ0.md.png)](https://imgtu.com/i/6yGHJ0)\r\n\r\n\r\n如上图，当进程发起recvfrom系统调用，其系统调用直到数据报到达内核并且从内核复制到应用进程的缓冲区中或者返回错误才返回。在返回前，进程一直阻塞。\r\n\r\n\r\n## 非阻塞I/O\r\n\r\n进程把一个套接字设置成非阻塞是在通知内核:当所请求的I/O操作要把本进程阻塞以至于要被挂起时，不挂起，而是返回一个错误。\r\n\r\n[![6yGXyF.md.png](https://s3.ax1x.com/2021/03/16/6yGXyF.md.png)](https://imgtu.com/i/6yGXyF)\r\n\r\n\r\n这种I/O模型说起来叫非阻塞I/O，其实只是在**数据报到达内核**这一阶段非阻塞，从**内核复制数据到应用进程**这一阶段是阻塞的。而且非阻塞付出的代价也是较大的。因为应用进程不知道什么时候I/O操作完成，所以它要不停的轮询内核，而轮询时要耗费CPU时间的。这种模型不常遇到，通常是在专门提供某一种功能的系统中才有。\r\n\r\n\r\n## I/O复用模型\r\n\r\n\r\n这种I/O模型被各种厂商大量使用，比如nginx使用epoll来处理数以万计的网络连接。**I/O复用模型也是阻塞的**，但是它和其他模型的阻塞于recvfrom调用上不同，它阻塞于select,poll,epoll调用上。那么都是阻塞，有什么不同吗？其他模型阻塞在recvfrom调用上，这意味着**一个进程(线程)只能处理一个网络连接**，而阻塞于select等系统调用上，可以同时处理数以千计的网络连接。select同时监听多个套接字，当任何一个套接字变为可读，通知应用进程，应用进程进程recvfrom系统调用，从内核复制数据到用户空间。\r\n\r\n[![6yGOQU.md.png](https://s3.ax1x.com/2021/03/16/6yGOQU.md.png)](https://imgtu.com/i/6yGOQU)\r\n\r\n\r\n如上图所示，在等待数据和将数据从内核复制到用户空间，进程都是阻塞的，所以这也是同步I/O。\r\n\r\n\r\n## 信号驱动I/O\r\n\r\n我们可以以信号的形式，当我们请求的描述符就绪时发送SIGIO信号给我们\r\n\r\n\r\n[![6yGqzT.md.png](https://s3.ax1x.com/2021/03/16/6yGqzT.md.png)](https://imgtu.com/i/6yGqzT)\r\n\r\n我们首先开启套接字的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。该信号调用立即返回，进程可以继续工作，也就是进程在第一阶段并不阻塞。当数据报准备好的时候，内核就为该进程发送一个SIGIO信号。随后进程可以在信号处理函数中调用recvfrom读取数据报，并通知主循环，数据已准备好，待处理，也可以立即通知主循环，让它读取数据报。此模型由于在第二阶段阻塞，所以也是同步I/O\r\n\r\n## 异步I/O\r\n\r\n\r\n异步I/O的工作机制是：告知内核启动某个操作，并在整个操作处理完毕后(数据报到达内核并从内核复制到用户空间)，通知进程。这与信号驱动I/O的区别在于，信号驱动I/O是告诉进程何时数据到达内核，而异步I/O是告诉进程何时数据完全处理完毕(即到达用户空间)。\r\n\r\n\r\n[![6yGbWV.md.png](https://s3.ax1x.com/2021/03/16/6yGbWV.md.png)](https://imgtu.com/i/6yGbWV)\r\n\r\n\r\n\r\n### 同步I/O异步I/O对比\r\n\r\n- 同步I/O: 导致请求进程阻塞，直到I/O操作完成。\r\n- 异步I/O: 不导致请求进程阻塞。\r\n\r\n\r\n> 毫无疑问,上述前四种I/O模型都以这样那样的形式阻塞着，所以他们都是同步I/O,只有最后一种模型是异步I/O\r\n\r\n\r\n[![6yDQET.md.png](https://s3.ax1x.com/2021/03/16/6yDQET.md.png)](https://imgtu.com/i/6yDQET)','2021-03-16 21:10:55.514303','2023-12-23 15:54:02.470122','阻塞，非阻塞，同步，异步',53,15),(39,'innodb和myisam的区别','特性 | innodb | myisam\r\n--- | ---|---\r\n锁 | 行级锁，并发量大，会消耗一定性能 | 表级锁，没有并发，开销最小\r\n事务 | 支持事务，默认的隔离级别是可重复读 | 不支持事务\r\n索引 | 整个表的数据基于聚簇索引建立，二级索引的值是主键 | 主键索引和二级索引一样\r\n崩溃后安全恢复|数据库崩溃自动恢复|崩溃后无法安全恢复\r\n高并发|采用MVVC来支持高并发| 读取时加共享锁，写入时加排它锁，支持一定的读并发','2021-03-17 21:02:20.706655','2023-12-23 15:54:02.480521','innodb和myisam的区别 简陋版',62,13),(40,'innodb事务性','> innodb能成为mysql的默认引擎，必定有它的过人之处，对事务的良好支持就是其中之一。\r\n\r\n## innodb的事务性\r\n\r\n事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功的对数据库应用该组查询的全部语句，那么就执行该查询。如果其中任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说，事务内的语句，要么全部成功，要么全部失败。\r\n\r\n\r\n事务具有原子性(atomicity)，一致性(consistency)，隔离性(isolation)，持久性(durability)，简称(ACID)。\r\n\r\n#### 原子性(atomicity)\r\n\r\n一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作，要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。\r\n\r\n---\r\n\r\n\r\n#### 一致性(consistency)\r\n\r\n数据库总是从一个一致性的状态转换到另外一个一致性的状态。事务提交前的修改是不会保存到数据库的。\r\n\r\n\r\n---\r\n\r\n#### 隔离性(isolation)\r\n\r\n通常来说，一个事务提交前的修改对其他事务是不可见的。比如有A,B两个事务，name=\'hah\'，A事务修改name=\'xix\'但是没有提交，这个时候B事务开启，查询name,name应该是\'hah\',因为A事务虽然修改了，但是未提交。当然准确来说，可见不可见要看隔离级别。如下\r\n\r\n##### 隔离级别\r\n\r\n隔离性比想象中的要复杂。在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所作的修改，哪些在事务内和事务间是可见的，哪些不可见。隔离级别越低，可执行的并发度越高，系统开销越小\r\n\r\n##### READ UNCOMMITTED(未提交读)\r\n\r\n在未提交读中，一个事务的修改，即使没有提交，对其他事务也是可见的。也就是A修改name=\'xix\',但是没提交，B事务读name=\'xix\'，但是这个时候A事务因为种种原因事务提交失败了，那么显而易见，B读到了脏数据，这被称为**脏读**(Dirty Read)。这个级别会导致很多问题，但是在性能方面，也没比其他的隔离级别好太多，除非有必要的理由，一般不用\r\n\r\n##### READ COMMITTED(提交读)\r\n\r\n大多数数据库系统的默认隔离级别都是READ COMMITTED(但MYSQL不是)。READ COMMITTED满足隔离性的简单定义，即一个事务开始时，只能看到已经提交的事务所作的修改，未提交的事务所作的修改对其他事务不可见。上述隔离级别中的问题在这个级别也不会出现。这个级别也叫**不可重复读**，因为执行同样的两次查询，可能得到不一样的结果(比如，数据库中name=\"c\",A事务读取name=\'c\',B事务修改name=\'d\',然后B提交,这个时候A没有提交，而是再次读取name,这时name=\'d\'，两次读取的name值不一样)。\r\n\r\n##### REPEATABLE READ(可重复读)\r\n\r\nmysql的默认隔离级别，解决了上述隔离级别不可重复读的问题。但是还有个问题没有解决，幻读(Phantom Read)。幻读就是指当一个事务读取一个范围内的记录时，另外一个事务又在该范围内插入了一条新的记录并提交，当之前的事务再次读取该范围的记录时，会产生幻行(Phantom Row)。\r\ninnodb殷勤通过MVVC(多版本并发)来解决幻读问题。接下来的文章会介绍MVVC\r\n\r\n##### SERIALIZABLE (可串行化)\r\n\r\n最高的隔离界别。通过强制事务串行执行，避免了前面所说的幻读。可串行化会给每一行数据加锁，可能导致大量的超时和锁征用问题。只在非常需要数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别\r\n\r\n\r\n---\r\n\r\n#### 持久性(durability)\r\n\r\n一旦事务提交，其所作的修改将永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。像隔离性一样，持久性也分不同级别，后续讨论\r\n\r\n\r\n---','2021-03-21 13:51:13.259666','2023-12-23 15:54:02.504109','innodb事务性,以及隔离级别',44,13),(41,'djangorestframework类继承关系','视图继承关系\r\n\r\n    View <-- APIView <-- GenericAPIView\r\n\r\n\r\n其中View中的as_view方法和dispatch方法把请求方法映射给相应的处理函数\r\n\r\n伪代码是这样的\r\n\r\n        class View:\r\n            \r\n            def as_view(cls, **initkwargs):\r\n            \r\n                def view(request, *args, **kwargs):\r\n                    return self.dispatch(request, *args, **kwargs)\r\n        \r\n                return view\r\n                \r\n            def dispatch(self, request, *args, **kwargs):\r\n                return handler(request, *args, **kwargs)\r\n                \r\n                \r\n路由往往是这样写的\r\n\r\n           \r\n    path(\'tag/\', views.Tag_List.as_view(), name=\"Tag_List\"),\r\n\r\n\r\n这就将url和类视图对应了起来\r\n\r\n\r\n而APIView继承了View,并实现了很多restframework自己的字段和方法\r\n\r\n比如字段有\r\n\r\n    ...\r\n    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES\r\n    throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES\r\n    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES\r\n    content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS\r\n    ...\r\n\r\n    \r\n其中最常使用的有authentication_classes和permission_classes，用于权限和认证\r\n\r\n方法有\r\n\r\n    ...\r\n    def get_authenticators(self):\r\n        return [auth() for auth in self.authentication_classes]\r\n        \r\n    def get_permissions(self):\r\n        return [permission() for permission in self.permission_classes]\r\n    ...\r\n    \r\n\r\nGenericAPIView继承了APIView,并添加了一些字段和方法\r\n\r\n\r\n字段\r\n\r\n        queryset = None\r\n    serializer_class = None\r\n\r\n    # If you want to use object lookups other than pk, set \'lookup_field\'.\r\n    # For more complex lookup requirements override `get_object()`.\r\n    lookup_field = \'pk\'\r\n    lookup_url_kwarg = None\r\n\r\n    # The filter backend classes to use for queryset filtering\r\n    filter_backends = api_settings.DEFAULT_FILTER_BACKENDS\r\n\r\n    # The style to use for queryset pagination.\r\n    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS\r\n    \r\n方法\r\n    \r\n    ...\r\n    def get_queryset(self):\r\n        return queryset\r\n    \r\n    def get_object(self):\r\n        return obj\r\n    \r\n    def get_serializer(self, *args, **kwargs):\r\n        return serializer_class(*args, **kwargs)\r\n    ...\r\n\r\n\r\n弄明白这些类之间的关系以及各自的作用，让我们在继承这些类并重写相应的字段和方法的时候更加的得心应手','2021-04-11 16:14:46.264073','2023-12-23 15:54:02.509131','djangorestframework类继承关系',32,7),(42,'djangorestframework最佳实践','> 上篇写了djangorestframework类的继承关系，这节说明如何巧妙的继承这些类，写入简单优雅而有效的视图处理函数\r\n\r\n---\r\n\r\n与类继承这种强耦合关系相比，mixin更灵活，不依赖于一个特定的类，在需要的时候，继承相关mixin就可以。\r\n\r\n\r\n以这个博客网站的实现为例\r\n\r\n\r\n获取全部博客的类视图\r\n\r\n\r\n        class PostView_List(mixins.ListModelMixin,\r\n                            generics.GenericAPIView):\r\n        \r\n        \r\n            queryset = Post.objects.all()\r\n            serializer_class = PostSer\r\n            pagination_class = post_SetPagination\r\n            \r\n            def get(self, request, *args, **kwargs):\r\n                return self.list(request, *args, **kwargs)\r\n            \r\n            def list(self, request, *args, **kwargs):\r\n                queryset = self.filter_queryset(self.get_queryset())\r\n                sync_pageviews(queryset)\r\n                page = self.paginate_queryset(queryset)\r\n                if page is not None:\r\n                    serializer = self.get_serializer(page, many=True)\r\n                    return self.get_paginated_response(serializer.data)\r\n        \r\n                serializer = self.get_serializer(queryset, many=True)\r\n                return Response(serializer.data)\r\n        \r\n\r\n\r\n我们要获得文章列表，只要继承ListModelMixin和GenericAPIView就可以了，ListModelMixin实现了list()函数，这个函数调用GenericAPIView的get_queryset()，paginate_queryset()等方法，直接返回序列化好的数据，我们要自定义返回值，只需要重写这个list(),比如我在其中加入了浏览量同步的功能。\r\n\r\n同理，我们要获得一篇指定的博客就继承RetrieveModelMixin，RetrieveModelMixin实现了retrieve()函数，这个函数返回一个指定的文章\r\n\r\n\r\n        class PostView_Retrieve(mixins.RetrieveModelMixin,\r\n                                generics.GenericAPIView):\r\n        \r\n            queryset = Post.objects.all()\r\n            serializer_class = PostSer\r\n        \r\n            def get(self,request, *args, **kwargs):\r\n                \r\n                ...\r\n                \r\n                return self.retrieve(request, *args, **kwargs)\r\n        \r\n            def retrieve(self, request, *args, **kwargs):\r\n        \r\n                pk = kwargs.get(\"pk\")\r\n                pk = str(pk)\r\n        \r\n                instance = self.get_object()\r\n        \r\n                redis_post_pfcount = CONN.pfcount(pk)\r\n        \r\n                CONN.hset(\"django_cache_post\",pk,redis_post_pfcount)\r\n                instance.pageviews = redis_post_pfcount\r\n                serializer = self.get_serializer(instance)\r\n        \r\n                return Response(serializer.data)\r\n                \r\n\r\n\r\n每次都继承GenericAPIView，好像有点冗余，不要紧，restframework实现了\r\n\r\n    ...\r\n    class RetrieveAPIView(mixins.RetrieveModelMixin,\r\n                          GenericAPIView):\r\n        def get(self, request, *args, **kwargs):\r\n            return self.list(request, *args, **kwargs)\r\n                          \r\n    class ListAPIView(mixins.ListModelMixin,\r\n                      GenericAPIView):\r\n                      \r\n        def get(self, request, *args, **kwargs):\r\n            return self.retrieve(request, *args, **kwargs)\r\n    ...       \r\n    \r\n\r\n所以上述类视图也可以这样写\r\n\r\n\r\n    class Idea_List(ListAPIView):\r\n    \r\n        queryset = Post.objects.all()\r\n        serializer_class = PostSer\r\n    \r\n        def list(self, request, *args, **kwargs):\r\n            \r\n            ...\r\n            \r\n            return Response(serializer.data)\r\n    \r\n\r\n给url实现处理函数就这样简单，继承相关mixin，在必要情况下自定义相关函数，添加自己的处理逻辑，就可以了。','2021-04-11 16:43:46.094193','2023-12-23 15:54:02.512950','djangorestframework最佳实践',59,7),(43,'前缀树的设计和实现','> 前缀树可以快速查找某个字符串或者字符前缀是否存在。广泛用于搜索领域\r\n\r\n节点定义val存储当前节点的值，is_node表示从根节点到当前节点的路径是否是一个单词，childrens为一个列表，存储以当前节点为前缀的单词\r\n\r\n\r\n        class PreTree:\r\n            def __init__(self,val):\r\n        \r\n                self.val = val\r\n                self.is_node = False\r\n                self.childrens = []\r\n        \r\n            def __repr__(self):\r\n                return f\"val:{self.val},is_node:{self.is_node},childrens:{self.childrens}\"\r\n                \r\n                \r\n\r\n\r\n具体实现\r\n\r\n    class Trie:\r\n    \r\n        def __init__(self):\r\n            \"\"\"\r\n            Initialize your data structure here.\r\n            \"\"\"\r\n            self.root = PreTree(0)\r\n    \r\n    \r\n    \r\n        def insert(self, word: str) -> None:\r\n            \"\"\"\r\n            Inserts a word into the trie.\r\n            \"\"\"\r\n            \r\n            t_root = self.root\r\n            l = len(word)\r\n            i = 0\r\n    \r\n            while i < l:\r\n    \r\n                childrens = t_root.childrens\r\n                childrens_len = len(childrens)\r\n    \r\n                sign = 0\r\n                while sign < childrens_len:\r\n                    if word[i] == childrens[sign].val:\r\n                        t_root = childrens[sign]\r\n                        i += 1\r\n                        break\r\n                    else:\r\n                        sign += 1\r\n    \r\n                 # word[i] 不在childrens里，加入\r\n                if sign == childrens_len:\r\n    \r\n                    t = PreTree(word[i])\r\n                    childrens.append(t)\r\n                    i += 1\r\n                    t_root = t\r\n                    if i==l:\r\n                        t.is_node = True\r\n            t_root.is_node = True\r\n    \r\n    \r\n        def search(self, word: str) -> bool:\r\n            \"\"\"\r\n            Returns if the word is in the trie.\r\n            \"\"\"\r\n            t_root = self.root\r\n            l = len(word)\r\n            i = 0\r\n    \r\n            while i<l and t_root:\r\n    \r\n                childrens = t_root.childrens\r\n                childrens_len = len(childrens)\r\n    \r\n                sign = 0\r\n    \r\n                # 遍历childrens,看word[i]是否在childrens中\r\n                while sign < childrens_len:\r\n    \r\n                    # 如果word[i]等于childrens[sign].val，直接break 开始word[i+1]查询\r\n                    if word[i] == childrens[sign].val:\r\n                        t_root = childrens[sign]\r\n                        i += 1\r\n                        break\r\n                    else:\r\n                        sign += 1\r\n    \r\n                # word[i]不在childrens里，直接返回错误\r\n                if sign == childrens_len:\r\n                    return False\r\n    \r\n            # word在前缀树中，返回True\r\n            if t_root.is_node==True:\r\n                return True\r\n            else:\r\n                return False\r\n    \r\n    \r\n        def startsWith(self, prefix: str) -> bool:\r\n            \"\"\"\r\n            Returns if there is any word in the trie that starts with the given prefix.\r\n            \"\"\"\r\n            t_root = self.root\r\n            l = len(prefix)\r\n            i = 0\r\n    \r\n            while i<l and t_root:\r\n    \r\n                childrens = t_root.childrens\r\n                childrens_len = len(childrens)\r\n    \r\n                sign = 0\r\n    \r\n                # 遍历childrens,看word[i]是否在childrens中\r\n                while sign < childrens_len:\r\n    \r\n                    # 如果word[i]等于childrens[sign].val，直接break 开始word[i+1]查询\r\n                    if prefix[i] == childrens[sign].val:\r\n                        t_root = childrens[sign]\r\n                        i += 1\r\n                        break\r\n                    else:\r\n                        sign += 1\r\n    \r\n                # word[i]不在childrens里，直接返回错误\r\n                if sign == childrens_len:\r\n                    return False\r\n    \r\n            return True\r\n\r\n代码有点冗余切丑陋。但是这个功能完备，时间复杂度和空间复杂度都挺好。最重要的是，这是我对前缀树一无所知的情况下，独自设计数据结构，独自写出来的算法题，意义颇大，写到博客，作为纪念。','2021-04-15 21:46:44.738032','2023-12-23 15:54:02.517354','前缀树的设计和实现',57,9),(44,'45.跳跃游戏2','> 贪心算法就是在已知的条件下，进行最优的选择。只能得到局部最优解，可能不是全局最优解\r\n\r\n来看看leetcode这道题\r\n\r\n给定一个非负整数数组，你最初位于数组的第一个位置。\r\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\r\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\r\n\r\n示例:\r\n    \r\n    输入: [2,3,1,1,4]\r\n    输出: 2\r\n    解释: 跳到最后一个位置的最小跳跃数是 2。\r\n         从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\r\n\r\n根据贪心算法，我们只求当前最优解，而不管以这个解为起点的最终解是否是最优解。\r\n\r\n所以以上实例输入，第一步我们在2,所以我们可以遍历接下来的3和1，让他们的索引和索引对应值相加，就是这个值最远可以到达的最远距离。可以轻易的写出while循环，结束条件为索引加索引对应值大于数组长度。\r\n\r\npython实现\r\n\r\n\r\n    class Solution:\r\n        def jump(self, nums: List[int]) -> int:\r\n    \r\n            l = len(nums)\r\n            n = 0\r\n    \r\n            i = 0\r\n    \r\n            while i<l-1:\r\n    \r\n                max1 = 0\r\n                max1_index = 0\r\n                j = i+1\r\n    \r\n                if nums[i] + i >= l-1:\r\n                    n += 1\r\n                    break\r\n    \r\n                while j<=i+nums[i] and j<l:\r\n    \r\n                    if max1 <= j + nums[j]:\r\n                        max1 = j + nums[j]\r\n                        max1_index = j\r\n\r\n                    j += 1\r\n    \r\n                i = max1_index\r\n                n += 1\r\n    \r\n            return n\r\n            \r\n只用到了几个整数变量，空间复杂度O(1)         \r\n当数组每个数都是1时候，得到最坏时间复杂度O(n)，其余测试用例时间复杂度均小于O(n)。\r\n\r\n其实上述代码依然可以优化，在遍历当前索引对应的范围时，当索引加索引对应值大于数组长度时，可以直接break。\r\n\r\n\r\n    if max1 <= j + nums[j]:\r\n        max1 = j + nums[j]\r\n        max1_index = j\r\n    \r\n    # 加上这两行    \r\n    if nums[j] + j >= l - 1:\r\n        break\r\n\r\n    j += 1','2021-04-16 16:44:09.517729','2023-12-23 15:54:02.521507','贪心算法实现leetcode跳跃游戏',43,9),(49,'二叉树，二叉搜索树的相关实现','> 找到实习后已经一两个月没写博客了，整天忙工作，也确实没余力再写博客。今天把工作忙完，忙里偷闲，写一点数据结构的东西。\r\n> 我愿称这一日为摸鱼元日\r\n\r\n这里大概实现了\r\n1. 二叉树的建立，遍历\r\n2. 二叉搜索树的建立，遍历\r\n3. 二叉平衡树的平衡旋转改天实现\r\n\r\n    \r\n    import random\r\n    \r\n    \r\n    class Node(object):\r\n    \r\n        def __init__(self, val, left=None, right=None):\r\n            self.val = val\r\n            self.left = left\r\n            self.right = right\r\n    \r\n        def __str__(self):\r\n            return f\"<val: {self.val}, left: {self.left}, right: {self.right}>\"\r\n    \r\n    \r\n    def build_tree(list):\r\n        \"\"\"\r\n        建立普通二叉树\r\n        \"\"\"\r\n        if list:\r\n            root = Node(list.pop(0))\r\n    \r\n        cur_node_list = [root]\r\n        while list:\r\n    \r\n            t = len(cur_node_list)\r\n    \r\n            for _ in range(t):\r\n    \r\n                cur_node = cur_node_list.pop(0)\r\n                cur_node.left = Node(list.pop(0))\r\n                cur_node_list.append(cur_node.left)\r\n                if list:\r\n                    cur_node.right = Node(list.pop(0))\r\n                    cur_node_list.append(cur_node.right)\r\n                else:\r\n                    break\r\n    \r\n        return root\r\n    \r\n    \r\n    def bfs_tree(root):\r\n        \"\"\"\r\n        层次遍历\r\n        \"\"\"\r\n        if not root:\r\n            return []\r\n    \r\n        res = [[root.val]]\r\n        cur_node_list = [root]\r\n    \r\n        while cur_node_list:\r\n    \r\n            l = len(cur_node_list)\r\n            cur_list = []\r\n            for _ in range(l):\r\n                cur_root = cur_node_list.pop(0)\r\n                if cur_root.left:\r\n                    cur_node_list.append(cur_root.left)\r\n                    cur_list.append(cur_root.left.val)\r\n                if cur_root.right:\r\n                    cur_node_list.append(cur_root.right)\r\n                    cur_list.append(cur_root.right.val)\r\n            if cur_list:\r\n                res.append(cur_list)\r\n        return res\r\n    \r\n    \r\n    def inorder_traversal(root):\r\n        \"\"\"\r\n        中序遍历\r\n        \"\"\"\r\n        res = []\r\n    \r\n        def help(root):\r\n    \r\n            if not root:\r\n                return\r\n    \r\n            help(root.left)\r\n            res.append(root.val)\r\n            help(root.right)\r\n    \r\n        help(root)\r\n        return res\r\n    \r\n    \r\n    def build_search_tree(list):\r\n        \"\"\"\r\n        建立二叉搜索树\r\n        \"\"\"\r\n        if not list:\r\n            return\r\n    \r\n        root = Node(list.pop(0))\r\n        while list:\r\n            val = list.pop(0)\r\n            def help(root):\r\n    \r\n                if val > root.val and not root.right:\r\n                    root.right = Node(val)\r\n    \r\n                elif val > root.val and root.right:\r\n                    help(root.right)\r\n    \r\n                elif val < root.val and not root.left:\r\n                    root.left = Node(val)\r\n    \r\n                elif val < root.val and root.left:\r\n                    help(root.left)\r\n            help(root)\r\n    \r\n        return root\r\n    \r\n    \r\n    class BalanceNode(Node):\r\n    \r\n        def __init__(self, val, left=None, right=None, weight=None):\r\n            self.weight = weight\r\n            super().__init__(val, left, right)\r\n    \r\n        def __str__(self):\r\n            return f\"<val: {self.val}, left: {self.left}, right: {self.right}, wight: {self.weight}>\"\r\n    \r\n    \r\n    if __name__ == \"__main__\":\r\n    \r\n        list2 = [1, 2, 3, 4, 5, 6, 7, 8]\r\n    \r\n        # 把数组建为普通二叉树\r\n        root = build_tree(list2)\r\n        print(f\"root: {root}\")\r\n    \r\n        # 二叉树层次遍历\r\n        bfs_res = bfs_tree(root)\r\n        print(f\"bfs_res: {bfs_res}\")\r\n    \r\n        # 生成一个100个元素的无序数组\r\n        list1 = [i for i in range(100)]\r\n        random.shuffle(list1)\r\n    \r\n        # 无序数组插入二叉搜索树\r\n        root = build_search_tree(list1)\r\n        print(f\"root: {root}\")\r\n    \r\n        # 对二叉搜索树进行中序遍历，为有序\r\n        res_inorder = inorder_traversal(root)\r\n        print(f\"res_inorder: {res_inorder}\")','2021-05-31 23:46:17.299824','2023-12-23 15:54:02.533245','主要是实现了二叉搜索树的建立，别的之前都写过，又写一遍，防止自己忘了',106,9),(50,'平衡二叉树的相关操作','> 写这个平衡二叉树的各种操作我用了一个半工作日。从某种程度上来说，我是个废物。\r\n\r\n这里实现了\r\n\r\n1. 平衡二叉树的定义\r\n2. 平衡二叉树的插入\r\n3. 平衡二叉树失衡后的再平衡\r\n4. 平衡二叉树的查找\r\n5. 平衡二叉树的删除\r\n6. 平衡二叉树的中序遍历\r\n\r\n\r\n\r\n    import random\r\n\r\n\r\n    class BalanceNode(object):\r\n\r\n        def __init__(self, val, left=None, right=None, weight=0, height=1):\r\n            self.val = val\r\n            self.left = left\r\n            self.right = right\r\n            self.weight = weight\r\n            self.height = height\r\n    \r\n        def __str__(self):\r\n            return f\"<val: {self.val}, left: {self.left}, right: {self.right}, height: {self.height}, wight: {self.weight}>\"\r\n\r\n\r\n    class AVLTree:\r\n\r\n        def __init__(self):\r\n    \r\n            self.root = None\r\n    \r\n        def __str__(self):\r\n            return self.root\r\n    \r\n        def _height(self, root):\r\n            \"\"\"\r\n            节点高度\r\n            \"\"\"\r\n            if not root:\r\n                return 0\r\n    \r\n            return max(self._height(root.left), self._height(root.right)) + 1\r\n    \r\n        def _weight(self, root):\r\n            \"\"\"\r\n            节点平衡因子\r\n            \"\"\"\r\n            if not root:\r\n                return 0\r\n    \r\n            return abs(self._height(root.left) - self._height(root.right))\r\n    \r\n        def _violate(self, root):\r\n            \"\"\"\r\n            判断节点是否平衡\r\n            \"\"\"\r\n            if not root:\r\n                return True\r\n    \r\n            return True if root.weight > 1 else False\r\n    \r\n        def RR(self, root):\r\n            \"\"\"\r\n            右旋\r\n            \"\"\"\r\n            assert type(root) is BalanceNode, \"root must be BalanceNode type\"\r\n    \r\n            if not root or not root.left:\r\n                return\r\n    \r\n            t = root.left.right\r\n            new_root = root.left\r\n            root.left = t\r\n            new_root.right = root\r\n    \r\n            root.height = self._height(root)\r\n            new_root.height = self._height(root)\r\n            root.weight = self._weight(root)\r\n            new_root.weight = self._weight(new_root)\r\n            return new_root\r\n    \r\n        def LL(self, root):\r\n            \"\"\"\r\n            左旋\r\n            \"\"\"\r\n            assert type(root) is BalanceNode, \"root must be BalanceNode type\"\r\n    \r\n            if not root or not root.right:\r\n                return\r\n    \r\n            t = root.right.left\r\n            new_root = root.right\r\n            root.right = t\r\n            new_root.left = root\r\n    \r\n            root.height = self._height(root)\r\n            new_root.height = self._height(root)\r\n            root.weight = self._weight(root)\r\n            new_root.weight = self._weight(new_root)\r\n            return new_root\r\n    \r\n        def LR(self, root):\r\n            \"\"\"\r\n            先左旋再右旋\r\n            \"\"\"\r\n            t = self.LL(root.left)\r\n            root.left = t\r\n            return self.RR(root)\r\n    \r\n        def RL(self, root):\r\n            \"\"\"\r\n            先右旋再左旋\r\n            \"\"\"\r\n            t = self.RR(root.right)\r\n            root.right = t\r\n            return self.LL(root)\r\n    \r\n        def _rotate(self, root):\r\n            \"\"\"\r\n            路由到相关旋转方法\r\n            \"\"\"\r\n            if root and self._height(root.left) > self._height(root.right):\r\n                if self._height(root.left.left) > self._height(root.left.right):\r\n                    t = self.RR(root)\r\n                else:\r\n                    t = self.LR(root)\r\n            elif root and self._height(root.right) > self._height(root.left):\r\n                if self._height(root.right.right) > self._height(root.right.left):\r\n                    t = self.LL(root)\r\n                else:\r\n                    t = self.RL(root)\r\n            return t\r\n    \r\n        def put(self, val):\r\n            \"\"\"\r\n            添加\r\n            \"\"\"\r\n            if not self.root:\r\n    \r\n                self.root = BalanceNode(val)\r\n                self.root.height = self._height(self.root)\r\n                self.root.weight = self._weight(self.root)\r\n                return\r\n    \r\n            root = self.root\r\n            def help(root):\r\n    \r\n                if not root:\r\n                    return BalanceNode(val)\r\n    \r\n                if val > root.val:\r\n                    root.right = help(root.right)\r\n                elif val < root.val:\r\n                    root.left = help(root.left)\r\n    \r\n                root.height = self._height(root)\r\n                root.weight = self._weight(root)\r\n    \r\n                if self._violate(root):\r\n                    return self._rotate(root)\r\n    \r\n                return root\r\n    \r\n            self.root = help(root)\r\n            if self._violate(self.root):\r\n                raise LogicalError(\"你的代码逻辑有误\")\r\n    \r\n    \r\n        def delete(self, val):\r\n            \"\"\"\r\n            删除\r\n            \"\"\"\r\n            root = self.root\r\n    \r\n            def dfs_find(root, val):\r\n                if not root:\r\n                    return NotFoundError(\"要删除的节点不存在\")\r\n    \r\n                if val > root.val:\r\n                    root.right = dfs_find(root.right, val)\r\n                elif val < root.val:\r\n                    root.left = dfs_find(root.left, val)\r\n                else:\r\n                    if not root.left:\r\n                        return root.right\r\n                    else:\r\n                        new_val = self.get_left_max(root.left).val\r\n                        root.val = new_val\r\n                        root.left = dfs_find(root.left, new_val)\r\n    \r\n                root.height = self._height(root)\r\n                root.weight = self._weight(root)\r\n    \r\n                if self._violate(root):\r\n                    return self._rotate(root)\r\n    \r\n                return root\r\n    \r\n            return dfs_find(root, val)\r\n    \r\n        def find(self, val):\r\n            \"\"\"\r\n            查找\r\n            \"\"\"\r\n            root = self.root\r\n    \r\n            def dfs_find(root):\r\n    \r\n                if not root:\r\n                    return False\r\n    \r\n                if val > root.val:\r\n                    return dfs_find(root.right)\r\n                elif val < root.val:\r\n                    return dfs_find(root.left)\r\n                else:\r\n                    return True\r\n    \r\n            return dfs_find(root)\r\n    \r\n    \r\n        def get_left_max(self, root):\r\n            \r\n            if not root:\r\n                return None\r\n    \r\n            while root.right:\r\n                root = root.right\r\n    \r\n            return root\r\n    \r\n        def inorder_traversal(self, root):\r\n            \"\"\"\r\n            中序遍历\r\n            \"\"\"\r\n            res = []\r\n    \r\n            def help(root):\r\n    \r\n                if not root:\r\n                    return\r\n    \r\n                help(root.left)\r\n                res.append(root.val)\r\n                help(root.right)\r\n    \r\n            help(root)\r\n            return res\r\n\r\n\r\n    class LogicalError(BaseException):\r\n        def __init__(self, msg):\r\n            self.msg = msg\r\n    \r\n        def __str__(self):\r\n            return self.msg\r\n    \r\n    class NotFoundError(BaseException):\r\n        def __init__(self, msg):\r\n            self.msg = msg\r\n    \r\n        def __str__(self):\r\n            return self.msg\r\n    \r\n    if __name__ == \"__main__\":\r\n    \r\n        avltree = AVLTree()\r\n        avltree.put(5)\r\n        avltree.put(4)\r\n        avltree.put(6)\r\n        avltree.put(2)\r\n        avltree.put(4.5)\r\n        avltree.put(1)\r\n    \r\n        print(avltree.root)\r\n    \r\n        avltree1 = AVLTree()\r\n        avltree1.put(3)\r\n        avltree1.put(2)\r\n        avltree1.put(4)\r\n        avltree1.put(1)\r\n        avltree1.put(2.5)\r\n        avltree1.put(0)\r\n    \r\n        print(avltree1.root)\r\n    \r\n        avltree2 = AVLTree()\r\n        avltree2.put(5)\r\n        avltree2.put(6)\r\n        avltree2.put(2)\r\n        avltree2.put(1)\r\n        avltree2.put(3)\r\n        avltree2.put(4)\r\n    \r\n        print(avltree2.root)\r\n    \r\n        avltree3 = AVLTree()\r\n        avltree3.put(2)\r\n        avltree3.put(1)\r\n        avltree3.put(4)\r\n        avltree3.put(3)\r\n        avltree3.put(5)\r\n        avltree3.put(3.5)\r\n        avltree3.delete(4)\r\n        print(avltree3.root)\r\n    \r\n        assert avltree3.find(2)\r\n        assert not avltree3.find(2.2)\r\n    \r\n        t = random.randint(10, 200)\r\n        list1 = [i for i in range(t)]\r\n        random.shuffle(list1)\r\n        print(f\"打乱后的list1: {list1}\")\r\n        avltree4 = AVLTree()\r\n        for i in list1:\r\n            avltree4.put(i)\r\n    \r\n        res_list1 = avltree4.inorder_traversal(avltree4.root)\r\n        print(f\"插入二叉平衡树后遍历出来的有序list1: {res_list1}\")\r\n        assert sorted(list1) == res_list1, \"逻辑有误，请检查代码\"\r\n    \r\n        # 删除一个节点  期待平衡树仍为有序\r\n        avltree4.delete(list1[3])\r\n        res_list2 = avltree4.inorder_traversal(avltree4.root)\r\n    \r\n        # 期待平衡树仍然平衡\r\n        assert not avltree4._violate(avltree4.root)\r\n    \r\n        avltree4.delete(list1[9])\r\n        res_list3 = avltree4.inorder_traversal(avltree4.root)\r\n        assert not avltree4._violate(avltree4.root)','2021-06-28 13:22:21.416169','2023-12-23 15:54:02.537305','',33,9),(51,'剑指offer56 数组中数字出现的次数','> 算法的意义是什么？用最小的计算机资源完成最多的事情。说人话就是完成一个程序，时间复杂度和空间复杂度要尽可能的低。\r\n\r\n\r\n\r\n    56. 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。\r\n    请找出那个只出现一次的数字\r\n\r\n\r\n比如\r\n\r\n    num = [4,3,3,3]\r\n    \r\n返回\r\n\r\n    4\r\n    \r\n\r\n对于这种题，第一反应是用哈希表，空间换时间。\r\n\r\n\r\n代码如下\r\n\r\n    \r\n    class Solution:\r\n        def singleNumber(self, nums: List[int]) -> int:\r\n            \r\n            dict1 = dict()\r\n    \r\n            for i in nums:\r\n                if i not in dict1:\r\n                    dict1[i] = 1\r\n                elif i in dict1 and dict1[i]!=2:\r\n                    dict1[i] += 1\r\n                elif i in dict1 and dict1[i]==2:\r\n                    del dict1[i]\r\n                \r\n            return [i for i in dict1.keys()][0]\r\n\r\n\r\n时间复杂度O(n)    \r\n空间复杂度O(n)\r\n\r\n\r\n还有一种惊为天人的解法。由题可知，除了一个数字出现了一次外，其他的都出现了三次。那么把每个数字写成二进制的形式，再把每个数字的每一个二进制位相加，对三取余，剩下的那个二进制数就是我们要求的数。\r\n\r\n比如\r\n\r\n\r\n\r\n    十进制    二进制\r\n    3           11\r\n    3           11\r\n    3           11\r\n    4          100\r\n            \r\n               1 3 3\r\n    \r\n二进制每位相加为1 3 3    \r\n对每一位对三取余结果为1 0 0, 而1 0 0 对应的十进制数字就是4, 也就是我们要的结果。\r\n\r\n代码如下\r\n\r\n    class Solution:\r\n        def singleNumber(self, nums: List[int]) -> int:\r\n    \r\n            s = nums\r\n            a = [0 for i in range(32)]\r\n            for i in s:\r\n                bin_num = bin(i)\r\n                n = 0\r\n                t = bin_num[2:]\r\n                l = len(t)\r\n                for j in range(l-1, -1, -1):\r\n                    a[n] += int(t[j])\r\n                    n += 1\r\n                    \r\n            L = len(a)\r\n            for q in range(L):\r\n                a[q] = a[q] % 3\r\n            res = 0\r\n            for p in range(L):\r\n                res += a[p] * pow(2, p)\r\n    \r\n            return res\r\n            \r\n时间复杂度O(n)    \r\n空间复杂度O(1)','2021-07-03 14:01:52.662777','2023-12-23 15:54:02.545326','',31,9),(52,'innodb缓冲池和抗扫描','> 计算机世界中处处存在速度上的鸿沟，相应的也出现了很多缝合的产物。比如人们为了弥补cpu和内存的巨大鸿沟，给cpu设置了相应的一，二，三级缓存，而内存本身就是为了弥补cpu和磁盘的速度鸿沟。web应用的瓶颈在于网络I/O和磁盘I/O。网络I/O无法避免，总归你是要通信的，而磁盘I/O可以有效避免，这可以极大提升web应用的响应速度。mysql缓冲池就是把常用数据放在内存中，让大多数查询可以直接从缓冲池中拿出，避免访问磁盘。\r\n\r\n\r\n#### 新数据插入到LRU链表的3/8处\r\n在innodb引擎下中，缓冲池往往占据内存80%的大小。\r\n\r\n缓冲池用链表来管理缓冲池中的内存页，并用一个特殊的LRU(最近最少使用算法)算法来淘汰和更新缓冲池中的内存页。\r\n\r\n当程序需要从数据库读一条数据，先到缓冲池中查看，若数据已经在缓冲池中，就直接从缓冲池中读取，若不在缓冲池中，就从数据库读取，然后把这条数据放到缓冲池中。\r\n\r\n上面说了，缓冲池根据改进过得LRU算法来管理。所以把从数据库读到的数据放入链表中，但是并不是放到链表的头部，而是放到链表的3/8处。这个数字由innodb_old_blocks_pct 参数控制，默认为3/8。值范围是 5 （缓冲池中的新页面非常快速地老化）到 95 （只有5％的缓冲池保留用于热页面，使得算法接近熟悉的LRU策略）\r\n\r\n\r\n        -------|---\r\n        new     old\r\n    \r\n\r\n3/8处为一个分界点，前面是表示活跃数据(经常访问的数据)，后面表示不活跃数据。当新数据放到3/8处，相应的，old链表的末尾会淘汰掉一个数据。\r\n\r\n当再次读取到链表中的数据(也就是命中缓存)，这个数据才会放到new链表的开头。\r\n\r\n#### 新数据为什么插入到LRU链表的距末尾3/8处\r\n\r\n这考虑到了全表扫描和预读。\r\n\r\n##### 全表扫描\r\n\r\n\r\n\r\n这里假设不是插入到3/8处，而是插到头部。\r\n\r\n试想如果有一个select * from tables语句。这将返回一个表的所有数据，而这个数据如果不在缓冲中，就会就将这个表中的数据都放放到缓冲池中。如果这个表很大，就会把很多热点数据都挤出缓冲池，而且这个表的数据以后可能再也用不上。这将降低缓冲池的命中率。\r\n\r\n如果插入到3/8处。\r\n\r\n那么这些数据至多把old链表的数据都挤出去，而new链表的热点数据都会安然无恙。\r\n\r\n\r\n##### 预读\r\n\r\n首先要明确的是磁盘I/O是很慢的，是物理操作。就是很原始的一个磁头在磁盘的上空转圈，一般是7200转/s。\r\n\r\n所以我们一般倾向于磁盘寻址找到数据位置后，一次多读取点。\r\n\r\ninnodb的预读就是这样的。\r\n\r\n###### 线性预读\r\n\r\n线性预读以extent为单位，而1extent=64page。线性预读着眼于将下一个extent提前读取到缓冲池中。\r\n\r\n通过使用配置参数innodb_read_ahead_threshold，控制触发innodb执行预读操作的时间。如果一个extent中的被顺序读取的page超过或者等于该参数变量时，Innodb将会异步的将下一个extent读取到buffer pool中，innodb_read_ahead_threshold可以设置为0-64的任何值(因为一个extent中也就只有64页)，默认值为56，值越高，访问模式检查越严格。\r\n\r\n这样做的原因为，当一个extent中的56个页都被连续访问了，那么我们认为大概率剩下的页和下一个extent也将被访问，就提前把他们读到缓冲池中。\r\n\r\n这样倾向于合并多个读请求，减少了磁盘I/O的次数。\r\n\r\n但是从缓冲池的角度看，这样是不对的。有的page我压根一次没读，你就给放到缓冲池中了，这不是把缓冲池污染了。\r\n\r\n这时候插入3/8又发挥用处了，污染也是仅仅把old链表污染了，无伤大雅。\r\n\r\n##### innodb_old_blocks_time\r\n\r\n保持缓冲池不被预读搅动的优化可以避免由于表或索引扫描引起的类似问题。 在这些扫描中，数据页面通常连续几次访问，并且永远不会再次触及。 配置参数 innodb_old_blocks_time 指定第一次访问页面之后的时间窗口（以毫秒为单位），在此期间可以访问该时间窗口而不移动到LRU列表的前端（最近使用的端点）。 默认值 innodb_old_blocks_time 是 1000 。 增加此值会使越来越多的块可能从缓冲池中更快地老化。','2021-07-05 14:56:27.346938','2023-12-23 15:54:02.549354','innodb缓冲池的实现细节和如何应付可能发生的搅乱缓冲池的行为',50,13),(53,'lru缓存机制的实现','> 最近最少使用缓存算法。即只要访问lru链表中有的元素，就放到lru头部，\r\n添加一个新的元素也是直接放到头部。lru链表容量一定，那么在lru链表\r\n满的时候，新进来的元素将挤掉lru链表末尾的元素。\r\n\r\n> 因为lru能在头部添加元素，也能在尾部删除元素，并且需要在lru内部删除\r\n元素，切题目要求一切操作在O(1)时间复杂度内完成。提到O(1),那么一定\r\n涉及到哈希表。而lru内部删除元素要在O(1)时间复杂度内实现，必须要用\r\n双端链表数据结构。\r\n\r\n\r\n\r\n### 双端链表\r\n\r\n    __author__ = \"HYuan\"\r\n\r\n    class Node(object):\r\n        def __init__(self, key, val, next=None, pre=None):\r\n            self.key = key\r\n            self.val = val\r\n            self.next = next\r\n            self.pre = pre\r\n    \r\n        def __repr__(self):\r\n            return f\"<key: {self.key}, val: {self.val}, next: {self.next} >\"\r\n\r\n\r\n    class LRUCache(object):\r\n\r\n        def __init__(self, capacity: int):\r\n            self.capacity = capacity\r\n            self.dict1 = dict()\r\n            self.head = Node(None, None)\r\n            self.tail = Node(None, None)\r\n            self.head.next = self.tail\r\n            self.tail.pre = self.head\r\n            self.size = 0\r\n    \r\n        def get(self, key: int) -> int:\r\n            if key not in self.dict1:\r\n                return -1\r\n            else:\r\n                node = self.dict1[key]\r\n                self.__remove_node(node)\r\n                self.__add_node(node)\r\n                return node.val\r\n    \r\n        def put(self, key: int, value: int) -> None:\r\n            if key not in self.dict1:\r\n                node = Node(key, value)\r\n                self.__add_node(node)\r\n                self.size += 1\r\n                self.dict1[key] = node\r\n                self.__check_is_overflow()\r\n            else:\r\n                node = self.dict1[key]\r\n                node.val = value\r\n                self.__remove_node(node)\r\n                self.__add_node(node)\r\n    \r\n        def __remove_node(self, node):\r\n            node.pre.next = node.next\r\n            node.next.pre = node.pre\r\n    \r\n        def __add_node(self, node):\r\n            node.next = self.head.next\r\n            self.head.next.pre = node\r\n            self.head.next = node\r\n            node.pre = self.head\r\n    \r\n        def __check_is_overflow(self):\r\n            if self.size > self.capacity:\r\n                node = self.tail.pre\r\n                key = node.key\r\n                self.__remove_node(node)\r\n                del self.dict1[key]\r\n                self.size -= 1\r\n    \r\n        def __str__(self):\r\n            return f\"{self.dict1} - - - {self.size}\"\r\n\r\n    c = LRUCache(5)\r\n    c.put(1, 1)\r\n    c.put(2, 2)\r\n    c.put(3, 3)\r\n    c.put(3, 4)\r\n    c.put(4, 4)\r\n    c.put(5, 4)\r\n    c.put(6, 4)\r\n    c.get(2)\r\n    c.put(7, 4)\r\n    \r\n    print(\"head: \", c.head)\r\n    print(\"dict1:\", c.dict1)\r\n\r\n     head:  <key: None, val: None, next: <key: 7, val: 4, next: <key: 2, val: 2, next: <key: 6, val: 4, next: <key: 5, val: 4, next: <key: 4, val: 4, next: <key: None, val: None, next: None > > > > > > >\r\n\r\n\r\n\r\n\r\n\r\n这里的大坑。\r\n\r\n本来应该在Node的__repr__里写\r\n    \r\n    return f\"<key: {self.key}, val: {self.val}, next: {self.next}, pre: {self.pre}>\"\r\n    \r\n可是一直报错，给我提示栈溢出。一个小时才找到原因。next和pre不能同时写在__repr__里。仔细想象也确实有问题。单向链表可以嵌套显示，双向链表咋嵌套\r\n显示呢？python也搞不明白。','2021-07-14 15:03:58.462139','2023-12-23 15:54:02.553797','双端链表和哈希表实现LRU缓存机制',94,9),(54,'redis过期键的实现','> redis中可以设置一个键的过期时间，到期后，按照一定的策略，将键删除。\r\n\r\n\r\n### 如何设置过期时间\r\n\r\nset key val\r\n\r\n将key的生存时间设置为ttl秒    \r\nexpire key ttl \r\n\r\n将key的生存时间设置为ttl毫秒    \r\npexpire key ttl \r\n\r\n将key的过期时间设置为timestamp所指定的秒数时间戳    \r\nexpireat key timestamp\r\n\r\n将key的过期时间设置为timestamp所指定的毫秒秒数时间戳    \r\npexpireat key timestamp\r\n\r\n\r\n### 保存过期时间\r\n\r\nredisdb结构的expire字典保存了数据库中所有键的过期时间，称这个字典为过期字典。\r\n\r\n- 过期字典的键为一个个指针。指针指向某个键对象\r\n- 过期字典的值是一个long long类型的整数， 这个整数保存了键所指向的数据库键的过期时间----一个毫秒精度的unix时间戳\r\n\r\n\r\n        typedef struct redisdb {\r\n            // .....\r\n            \r\n            // 过期字典，保存着指向键的指针和过期时间\r\n            dict *expires;\r\n\r\n            // ..... \r\n        } redisdb;\r\n        \r\n### 过期键的删除策略\r\n\r\n- 定时删除: 在设置键的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作\r\n- 惰性删除: 放任键过期不管，但是每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键; 如果没有过期, 就返回该键。\r\n- 定期删除: 每隔时间，程序就对数据库进行一次检查，删除里边的过期键。至于要删除多少过期键，以及要检查多少数据库，则由具体的算法决定。\r\n\r\n\r\n#### 定时删除\r\n\r\n定时删除是对内存最友的，也是对cpu最不友好的。定时删除是每创建一个键，就需要创建一个定时器，在键过期时将其删除。在过期键比较多的情况下， 删除过期键这一行会耗费cpu时间(盲猜是定时器要不听轮询，看键值是否过期)。在内存不紧张，但是cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。\r\n\r\n#### 惰性删除\r\n\r\n惰性删除是对cpu最友好的。只有在取一个键值的时候，才会对其进行检查，如果过期就把它删除，并对取键操作返回空值。如果不过期，就返回。这个做法有一个潜在的巨大隐患。如果一个键过期了，然后在相当长的时间内，没有对这个键进行访问，那么这个过期的键就会一直存在，白白占用内存，在一定程度上，这是一种内存泄漏\r\n\r\n#### 定期删除\r\n\r\n定期删除总结上述两种删除策略的优点。即在cpu消耗和内存消耗之间找到平衡点。redis使用的是惰性删除和定期删除两种策略。\r\n- 定时删除占用太多的cpu时间，影响服务器的响应时间和吞吐量\r\n- 惰性删除浪费太多内存，有内存泄漏的危险\r\n\r\n定期删除对着两种策略就行整合和折中\r\n- 定期删除每隔一段时间执行一次删除过期键的操作，并通过限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响。  \r\n- 定期删除减少过期键对内存的浪费\r\n\r\n\r\n定期删除策略的实现\r\n\r\n过期键的定期删除策略由redis.c/activeExpireCycle函数实现。redis服务器周期性调用这个函数。函数在规定时间内，分多次遍历服务器中的各个数据库，从各个数据库的expires字典中随机检查一部分键的过期时，并删除其中的过期键。','2021-07-18 16:45:48.519443','2023-12-23 15:54:02.558571','redis如何设置过期键，以及删除过期键的具体策略',52,13),(55,'记一次列表不同操作时间复杂度差别造成的算法性能的巨大差异','> Python中的list.pop()是删除列表末尾的一个元素，时间复杂度为O(1)。而list.pop(0)是删除列表头部的一个元素，这个时间复杂度是O(n)。因为删除头部的元素，列表中其他的所有元素都需要向前移一位，而删除尾部元素，列表中的其他元素不变。\r\n\r\n这个细节造成了算法性能的巨大差异\r\n\r\n在题目\r\n\r\n剑指offer51. 数组中的逆序对\r\n\r\n> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\r\n\r\n\r\n    示例 1:\r\n    \r\n    输入: [7,5,6,4]\r\n    输出: 5\r\n\r\n这个题可以直接遍历每个元素，然后遍历这个元素之前的所有元素，得到大于这个元素的元素的数量，时间复杂度为O(N*N),时间复杂度太高。\r\n\r\n\r\n而归并排序就是把序列分为左右两份，并且从底到上的递归排序途中，左右两份是有序的，所以很容易在排序途中对左边有几个元素大于右边，进行统计。\r\n\r\nPython归并排序实现(n* n*logn)\r\n\r\n\r\n    class Solution:\r\n        def __init__(self):\r\n            self.res = 0\r\n    \r\n        def reversePairs(self, nums: List[int]) -> int:\r\n            def merge_sort(num):\r\n                if len(num) <= 1:\r\n                    return num\r\n                mid = len(num) // 2\r\n                left = merge_sort(num[:mid])\r\n                right = merge_sort(num[mid:])\r\n    \r\n                t = []\r\n                while left and right:\r\n                    if left[0] > right[0]:\r\n                        self.res += len(left)\r\n                        t.append(right.pop(0))   # 这里时间复杂度为O(n)\r\n                    else:\r\n                        t.append(left.pop(0))    # 还有这里\r\n                if left: t += left\r\n                else: t += right\r\n    \r\n                return t\r\n    \r\n            t = merge_sort(nums)\r\n            return self.res\r\n\r\n\r\n#### leetcode直接超出时间显示\r\n\r\nPython归并排序实现(n*logn)\r\n\r\n    class Solution:\r\n        def __init__(self):\r\n            self.res = 0\r\n    \r\n        def reversePairs(self, nums: List[int]) -> int:\r\n            def merge_sort(num):\r\n                if len(num) <= 1:\r\n                    return num\r\n                mid = len(num) // 2\r\n                left = merge_sort(num[:mid])\r\n                right = merge_sort(num[mid:])\r\n    \r\n                t = []\r\n                while left and right:\r\n                    if left[-1] > right[-1]:\r\n                        self.res += len(left)\r\n                        t.append(right.pop()) # 时间复杂度为O(1)\r\n                    else:\r\n                        t.append(left.pop())\r\n                if left: t += left[::-1]\r\n                else: t += right[::-1]\r\n    \r\n                return t[::-1]\r\n    \r\n            t = merge_sort(nums)\r\n            return self.res\r\n\r\n这个就牛逼了，超过百分之九十多\r\n      \r\n> 执行用时：\r\n908 ms\r\n, 在所有 Python3 提交中击败了\r\n95.88%\r\n的用户\r\n\r\n> 内存消耗：\r\n20.8 MB\r\n, 在所有 Python3 提交中击败了\r\n46.72%\r\n的用户','2021-08-03 18:04:09.777398','2023-12-23 15:54:02.564216','Python中的list.pop()是删除列表末尾的一个元素，时间复杂度为O(1)。而list.pop(0)是删除列表头部的一个元素，这个时间复杂度是O(n)。因为删除头部的元素，列表中其他的所有元素都需要向前移一位，而删除尾部元素，列表中的其他元素不变。',78,9),(56,'golang继承，多态，多继承','golang的继承，多态，多继承\r\n    \r\n    package main\r\n    \r\n    import (\r\n    	\"fmt\"\r\n    	\"strconv\"\r\n    )\r\n    \r\n    // 定义人\r\n    type Human struct {\r\n    	name string\r\n    	age int\r\n    }\r\n    \r\n    // 人的方法\r\n    func (this *Human) get_age() int{\r\n    	return this.age\r\n    }\r\n    \r\n    // 人的方法\r\n    func (this *Human) get_name() string {\r\n    	return this.name\r\n    }\r\n    \r\n    // 定义狗\r\n    type Dog struct {\r\n    	color string\r\n    }\r\n    \r\n    // 狗的方法\r\n    func (this *Dog) run(name string) string{\r\n    	return name + \" 跑的贼快\"\r\n    }\r\n    \r\n    // 狗也有get_name方法\r\n    func (this *Dog) get_name() string{\r\n    	return \"dog name\"\r\n    }\r\n    \r\n    // 超人继承人, 自动继承人的方法, 人的属性\r\n    type SuperMan struct {\r\n    	Human\r\n    	Dog\r\n    	action string\r\n    }\r\n    \r\n    // 子类重写父类\r\n    func (this *SuperMan) get_age() string{\r\n    	return strconv.Itoa(this.age) + this.action\r\n    \r\n    }\r\n    \r\n    // 子类新方法\r\n    func (this *SuperMan) fly() string {\r\n    	return this.name + \" can \" + this.action\r\n    }\r\n    \r\n    \r\n    func main() {\r\n    	// 实例化人类\r\n    	h := Human{\"hyuan\", 21}\r\n    \r\n    	// 实例化超人\r\n    	s := SuperMan{\r\n    		h,\r\n    		Dog{color: \"black\"},\r\n    		\"fly\",\r\n    	}\r\n    	fmt.Println(s.action)\r\n    	fmt.Println(s.fly())\r\n    	fmt.Println(s.run(\"xxx\"))\r\n    \r\n    	// 当继承的两个类有相同的方法, 不能直接调用\r\n    	//fmt.Println(s.get_name())  // Ambiguous reference \'get_name\'\r\n    \r\n    	// 显式的调用其中一个父类的方法\r\n    	fmt.Println(s.Dog.get_name())\r\n    \r\n    }','2021-10-17 14:10:36.999330','2023-12-23 15:54:02.569587','golang继承，多态，多继承',44,18),(57,'三种装饰器的实现以及装饰器原理','> 装饰器本质上还是一个函数，他的返回值是一个函数，这意味着他可以对他的返回值再次发起调用。不用@decorate语法糖可以同样实现装饰器的效果，python实现一个这样的语法糖让代码看起来更优雅，更pythonic\r\n\r\n\r\n### 装饰器和被装饰的函数都不带参数\r\n\r\n\r\n\r\n    def decorate(fun):\r\n        print(\"xxx\")\r\n        return fun\r\n    \r\n    \r\n    @decorate\r\n    def fun1():\r\n        return 100\r\n    \r\n    \r\n    # 1\r\n    q = decorate(fun1)\r\n    print(q)\r\n    \r\n    # 2\r\n    a = fun1()\r\n    print(a)\r\n\r\n上述1等价于2\r\n\r\n\r\n### 装饰器不带参数，被装饰的函数带参数\r\n\r\n    def decorate(fun):\r\n        def f1(*args, **kwargs):\r\n            print(\"qqqqq\")\r\n            a = fun(*args, **kwargs)\r\n            return a\r\n        return f1\r\n    \r\n    \r\n    @decorate\r\n    def fun1(x):\r\n        return x\r\n    \r\n    # 1\r\n    q = decorate(fun1)\r\n    c = q(1000)\r\n    print(c)\r\n    \r\n    # 2\r\n    a = fun1(1000)\r\n    print(a)\r\n    \r\n上述1的效果等同与2\r\n\r\n### 装饰器带参数，被装饰的函数也带参数\r\n\r\n    def f2(name):\r\n        def decorate(fun):\r\n            def f1(*args, **kwargs):\r\n                print(\"xxx\")\r\n                a = fun(*args, **kwargs)\r\n                print(name)\r\n                return a\r\n            return f1\r\n        return decorate\r\n    \r\n    \r\n    @f2(name=\"hyuan\")\r\n    def fun1(x):\r\n        return x\r\n    \r\n    \r\n    # 1\r\n    g = fun1(1000)\r\n    print(g)\r\n    \r\n    # 2\r\n    q = f2(name=\"hyuan\")\r\n    a = q(fun1)\r\n    b = a(1000)\r\n    print(b)\r\n    \r\n    # 3\r\n    cc = f2(name=\"xxx\")(fun1)(1000)\r\n    print(cc)\r\n\r\n上述1，2，3效果一样','2021-12-05 14:10:48.883725','2023-12-23 15:54:02.573545','按照装饰器是否带参数和被装饰函数是否带参数来实现三个装饰器',47,3),(58,'迭代器和生成器','### 迭代器\r\n\r\n> python是鸭子类型，也就是看你是不是一个迭代器，只要你的行为是迭代器，那你就是一个迭代器。\r\n\r\n要实现迭代器首先要实现__iter__方法，并且__iter__方法返回一个可迭代对象，再由这个可迭代对象的_next__方法是来完成实际的迭代操作。\r\n\r\n\r\n如下例子是通过__iter__方法来返回一个list1,由list自带的__next__来实现具体迭代操作\r\n\r\n    class A:\r\n        def __init__(self):\r\n            self.list1 = []\r\n    \r\n        def __iter__(self):\r\n            return iter(self.list1)\r\n    \r\n    \r\n    c = A()\r\n    c.list1.append(1)\r\n    c.list1.append(2)\r\n    c.list1.append(3)\r\n    \r\n    for i in c:\r\n        print(i)\r\n\r\n\r\n如下例子是通过__iter__方法来返回自身,然后自己实现__next__来实现具体迭代操作\r\n\r\n\r\n    class B:\r\n        def __iter__(self):\r\n            self.a = 1\r\n            return self\r\n    \r\n        def __next__(self):\r\n            if self.a <= 20:\r\n                x = self.a\r\n                self.a += 1\r\n                return x\r\n            else:\r\n                raise StopIteration\r\n    \r\n    x = B()\r\n    for j in x:\r\n        print(j)\r\n\r\n### 生成器\r\n\r\n> 函数中只要出现了yield语句，那么他就是一个生成器。生成器只有响应迭代操作的时候才运行。\r\n\r\n        def fun1(n):\r\n            i = 1\r\n            try:\r\n                while i <= n:\r\n                    yield i\r\n                    i += 1\r\n            except StopIteration:\r\n                pass\r\n        \r\n        qqq = fun1(3)\r\n        # for i in qqq: \r\n        #     print(i)    \r\n        \r\n        print(next(qqq))\r\n        print(next(qqq))\r\n        print(next(qqq))','2021-12-06 16:07:21.381282','2023-12-23 15:54:02.579098','迭代器和生成器',38,3),(59,'I/O多路复用简概','### 流\r\n\r\n- 可以进行I/O操作的内核对象\r\n- 文件，管道，套接字\r\n- 流的入口: 文件描述符(fd)\r\n\r\n### I/O操作\r\n\r\n- 所有对流的读写操作，我们都可以称为IO操作\r\n\r\n### 阻塞\r\n\r\n- 阻塞等待: 阻塞时当前线程/进程挂起，不占用cpu宝贵的时间片\r\n    - 阻塞等待的缺点: 不能很好的处理多个I/O请求的问题。一个程序有多个地方需要I/O操作，那么这些i/o操作只能一个一个执行。\r\n- 非阻塞忙询: 不停的判断文件描述符是否就绪，占用cpu资源\r\n\r\n### 如何解决大量IO请求读写的问题\r\n\r\n1. 阻塞等待 + 多线程/多进程 需要开辟线程，资源消耗大。\r\n2. 非阻塞 + 忙轮询。cpu在做大量的判断，浪费cpu资源\r\n3. IO多路复用\r\n\r\n### 多路I/O复用\r\n\r\n- 既能够阻塞等待，不浪费资源，也能够同一时刻监听多个I/O请求的状态\r\n\r\n### select(与平台无关)\r\n\r\n- 当有i/o请求的时候依然阻塞，但是不是阻塞在文件描述符上，而是阻塞在select上。select来管理大量的文件描述符，当有文件描述符就绪，告诉当前线程，但是并不告诉是哪个文件描述符就绪了，这个时候当前线程依然需要遍历文件描述符列表来查看是哪个就绪了。select管理的文件描述符大小有限制，一般为1024。\r\n\r\n### epoll(Linux)\r\n\r\n- 同select的差别为。select依然是监听大量的文件描述符，当有文件描述符就绪时，直接把就绪的文件描述符告诉应用线程，应用线程无序再遍历文件描述符列表。并且，epoll监听的文件描述符列表很大(系统可以打开的文件数目cat /proc/sys/fs/file-max可以查看)','2022-01-04 23:37:17.588432','2023-12-23 15:54:02.583131','为什么要I/O多路复用',52,15),(60,'像操作python List一样操作go Slice','> 我发现在golang中并没有函数来快捷操作切片，这里实现一下。\r\n\r\n\r\n    package main\r\n    \r\n    import (\r\n    	\"fmt\"\r\n    	\"reflect\"\r\n    )\r\n    \r\n    // 实现切片快捷操作，让go slice像python list那样友好\r\n\r\n    func main()  {\r\n    	c := []int{1,2,3}\r\n    	insert(&c, 22, 2)  // c == [1, 2, 22, 3]\r\n    	remove(&c, 1) // c == [1, 22, 3]\r\n    	q1 := pop(&c) // [22, 3]\r\n    	fmt.Println(q1) // 1\r\n    	q2 := popHead(&c) // [3]\r\n    	fmt.Println(q2) // 22\r\n    }\r\n\r\n    // 删除指定索引的元素\r\n    func remove(nums interface{}, index int){\r\n    	var val = reflect.ValueOf(nums)\r\n    	var value = val.Elem()\r\n    	var l = value.Len()\r\n    	if index >= l || index < 0 {\r\n    		panic(\"index error\")\r\n    	}\r\n    	value.Set(reflect.AppendSlice(value.Slice(0,index), value.Slice(index+1, l)))\r\n    }\r\n    \r\n    // 插入一个元素到指定index的Slice中\r\n    func insert(nums interface{}, num interface{}, index int)  {\r\n    	var val = reflect.ValueOf(nums)\r\n    	var value = val.Elem()\r\n    	l := value.Len()\r\n    	if index < 0 || index > l {\r\n    		panic(\"index error\")\r\n    	}\r\n    	ne := reflect.MakeSlice(reflect.SliceOf(reflect.TypeOf(num)), 1, 1)\r\n    	ne.Index(0).Set(reflect.ValueOf(num))\r\n    	qq := reflect.AppendSlice(ne, value.Slice(index, l))\r\n    	value.Set(reflect.AppendSlice(value.Slice(0, index), qq))\r\n    \r\n    }\r\n    \r\n    // 弹出切片最后一个元素并返回\r\n    func pop(nums interface{}) interface{}{\r\n    	var val = reflect.ValueOf(nums)\r\n    	var value = val.Elem()\r\n    	l := value.Len()\r\n    	if l < 1{\r\n    		panic(\"index error\")\r\n    	}\r\n    	res := value.Index(l-1)\r\n    	value.Set(value.Slice(0, l-1))\r\n    	return res.Interface()\r\n    }\r\n    \r\n    // 弹出切片第一个元素并返回\r\n    func popHead(nums interface{}) interface{}{\r\n    	var val = reflect.ValueOf(nums)\r\n    	var value = val.Elem()\r\n    	l := value.Len()\r\n    	if l < 1{\r\n    		panic(\"index error\")\r\n    	}\r\n    	res := value.Index(0)\r\n    	value.Set(value.Slice(1, l))\r\n    	return res.Interface()\r\n    }\r\n\r\n\r\n为了编写通用于任何切片类型的函数，需要一个类似泛型的机制，go语言目前用空接口实现了类似泛型的机制。所以这里第一个参数为空接口。golang有完善的反射机制。在接口中存储了变量值和类型。可以用reflect包来从空接口中拿到数据和类型，并对数据进行操作。','2022-01-09 23:40:20.988617','2023-12-23 15:54:02.586927','一个小轮子',65,18),(61,'论协程','> 进程是资源分配的基本单位，线程是操作系统调度的基本单位，那么在有进程和线程的情况下为什么又有了协程，以及golang和python分别关于协程的实现。\r\n\r\n#### 没有进程的操作系统\r\n在早期操作系统中同一时刻只能处理一件事情，也就是当有多个任务需要处理的时候，这些任务只能排队进行。然而cpu和磁盘，网络是有速度上的鸿沟的，并且这个鸿沟是好几个数量级级别的。也就是说，当程序在读磁盘或者网络的时候，cpu只能呆呆的等着，这无疑浪费了宝贵的cpu资源，计算机的吞吐量也很低。\r\n\r\n#### 只有进程的操作系统\r\n为了解决上述问题，操作系统引入了进程的概念。进程是一个程序运行中的实体，它包含了一个程序可运行的所有必要因素，比如地址空间，文件描述符，全局变量等。进程之间是相互隔离的，也就是多个进程可以同时运行，互不影响。在多核cpu环境下，和cpu核数相同的进程在同一时刻是并行运行的，在单核cpu环境下，多个进程是并发运行的，也就是在同一时刻只有一个进程在运行。\r\n\r\n进程拥有了资源，让同时处理多任务成为了可能，然而这是有代价的。现代操作系统一般是以时间片算法调度多个进程的，当有进程因为网络i/o或者磁盘io阻塞时，或者时间片用完时，或者被优先级更高的进程抢占cpu时，操作系统就会将进程挂起，转而运行别的处于就绪状态的进程。这就是进程切换，或者叫上下文切换。进程上下文切换是有相当大的开销的。因为操作系统需要将当前进程的运行状态保存起来，然后加载另一个就绪的进程(主要是切换页表，切换内核态堆栈，硬件上下文等等)。\r\n\r\n那么如何避免或者缩小进程切换的开销呢？用线程。线程是调度的基本单位，却不拥有资源。多个线程共享进程的地址空间，文件描述符并且线程只拥有栈，程序计数器等资源。这使得线程的切换开销要比进程小的多(不需要切换页表，不会扰乱cpu的缓存机制)。\r\n\r\n#### 引入线程的操作系统\r\n进程拥有资源但不频繁调度，让拥有资源少的线程来调度，来提高并发，这样看起来就没问题了。(这里说个题外话，一般后端服务器处理用户请求，有两种方式，1是用多线程的方式，一个用户请求就创建的一个线程来服务这个用户请求。2是IO多路复用，在一个线程中监听多个用户请求(select,poll,epoll等))。但是随着用户的增长，对并发量越来越高的挑战，线程切换的开销也变的不可忽视。于是有了协程。\r\n\r\n终于步入正题了。\r\n\r\n#### 协程\r\n协程被称为用户态线程，也就是操作系统并不知道协程的存在，它还是以为是在调度一个个的线程。协程的思路是尽可能的减少调度。操作系统会在时间片到期,网络io,磁盘io时调度线程。时间片到期这个调度我们不可避免，因为操作系统的调度准则是公平，不让一部分线程长期得不到cpu，处于饥饿状态。网络io,磁盘io这两个调度可以避免。\r\n\r\n在python中,当协程遇到阻塞,需要显示的用await关键词挂起当前协程，让出处理器,让同一线程下的其他协程运行，而协程上下文的切换由解释器实现,不需要陷入内核，操作系统对此全然不知，自然也就没有切换开销了。\r\n\r\n而golang的协程实现更是牛逼，python还需要开发者显示的让出cpu, golang则完全不需要，当协程因为io阻塞时，golang会根据GMP调度算法(由GMP调度器实现，也许以后会专一写篇关于GMP的文章)自动的调度协程，让开发者像用线程一样用协程，却不用担忧线程的开销。','2022-01-23 00:45:54.811725','2023-12-23 15:54:02.590805','为什么用协程？',55,15),(62,'redis简单动态字符串SDS实现','## 简单动态字符串\r\n\r\n### 简要\r\n1. 大多数情况下，redis使用SDS作为字符串表示。\r\n2. SDS具有以下优点\r\n    1. 常数复杂度获取字符串长度\r\n    2. 杜绝缓冲区溢出(当字符串的底层字符数组不够用时，自动扩容)\r\n    3. 减少修改字符串长度时所需的内存重分配次数\r\n    4. 二进制安全\r\n    5. 兼容部分C字符串函数\r\n\r\n---\r\n\r\n### SDS定义\r\n\r\n    \r\n    struct sdshdr{\r\n    \r\n        // 记录buf数组中已使用字节数量\r\n        // 等于SDS所保存字符串的长度\r\n        int len;\r\n        \r\n        // 记录buf数组中未使用字节的和数量\r\n        int free;\r\n        \r\n        // 字节数组，用于保存字符串。\r\n        char buf[];\r\n    }\r\n\r\n#### 常数复杂度获取字符串长度\r\n\r\n直接用sdshdr结构体中的len属性\r\n\r\n#### 杜绝缓冲区溢出\r\n\r\n当底层数组不够时，自动扩容\r\n\r\n#### 减少修改字符串时带来的内存重分配次数。\r\n\r\n> 内存分配可能设计系统调用，而系统调用往往是比较耗时的操作。为了避免频繁的系统调用，redis采用空间预分配和惰性空间释放。\r\n\r\n- 空间预分配\r\n    - 当SDS需要空间扩展时，除了分配字符串本身要用的空间，还会分配额外空间\r\n        1. 如果对SDS进行修改后，已使用字符串长度小于1MB，那么会额外分配和已使用空间一样大小的空间。比如原来字符串为\"hello\",长度为5，把字符串\"world\"添加上去，本来分配5个空间就够了，但是为了避免频分内存分配直接分配20个((原来字符串长度+拼接字符串长度) * 2)。\r\n        2. 如果修改后，已使用字符串长度大于1MB.那么会直接多分配1MB的空间，比如修改后的长度为30MB，那么多分配1MB，也就是buf数组实际长度30mb + 1mb + 1byte(空字符串长度)\r\n\r\n\r\n- 惰性空间释放\r\n    - 当从原来字符串删除一部分时，buf数组的多余空间不立即回收，而是等需要的直接使用','2022-02-05 23:19:34.158122','2023-12-23 15:54:02.604838','redis简单动态字符串SDS实现',35,13),(63,'redis链表实现','## 链表\r\n\r\n### 简要\r\n1. 链表被广泛用于redis的各种功能，比如列表键，发布与订阅，慢查询，监视器等。\r\n2. redis的链表实现是无环双端链表，每个链表节点由listNode结构表示\r\n3. 每个链表使用一个list结构表示，这个结构带有表头节点指针，表尾节点指针，以及链表长度等信息。\r\n4. redis的链表节点可以保存不同类型的值。\r\n\r\n---\r\nlistNode\r\n\r\n    typedef struct listNode{\r\n    \r\n        // 前置节点\r\n        struct listNode *prev;\r\n        \r\n        // 后置节点\r\n        struct listNode *next;\r\n        \r\n        // 节点的值,void可以保存任意类型\r\n        void *value;\r\n    \r\n    }listNode\r\n\r\nlist\r\n\r\n    typedef struct list{\r\n        \r\n        // 表头节点\r\n        listNode *head;\r\n        \r\n        // 表尾节点\r\n        listNode *tail;\r\n        \r\n        // 链表所包含的节点数量\r\n        unsigned long len;\r\n        \r\n        // 节点值复制函数\r\n        void * (*dup) (void *ptr);\r\n        \r\n        // 节点值释放函数\r\n        void * (*free) (void *ptr);\r\n        \r\n        // 节点值对比函数\r\n        int (*match) (void *ptr, void *key);\r\n        \r\n    }list;\r\n\r\n### 由list和listNode结构体易得redis链表实现的特性\r\n\r\n1. 双端\r\n2. 带表头，表尾指针，所以访问表头表尾时间复杂度为O(1)\r\n3. 带链表长度计数器，len属性实时记录链表长度\r\n4. 多态。链表节点可以保存任意类型值。','2022-02-05 23:20:25.801899','2023-12-23 15:54:02.599174','redis链表实现',35,13),(64,'redis哈希表实现','## 哈希表\r\n\r\n### 简要\r\n1. 字典的底层实现是哈希表，字典被用于redis的数据库和哈希键。\r\n2. redis中的字典包含两个哈希表，一个平时用，一个仅在进行rehash时使用。\r\n3. redis使用Murmurhash2算法来计算哈希键的值\r\n4. redis使用链接地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。\r\n5. 对哈希表进行扩展或者收缩操作时，程序会把现有哈希表的所有键值对rehash到新哈希表，并且这个rehash是渐进式的，平摊到对字典的增加，删除，查找，更新操作上\r\n\r\n---\r\n- 字典数据结构\r\n\r\n        typedef struct dictht{\r\n            // 哈希表数组,数组内有ht[0],ht[1]两个哈希表。\r\n            dictEntry **table;\r\n            // 哈希表大小\r\n            unsigned long size;\r\n            // 哈希表掩码，用于计算索引值，总是size-1;\r\n            ungisned long sizemask;\r\n            // 哈希表中已有节点的数量\r\n            unsigned long used;\r\n        }dictht;\r\n\r\n- 解决键冲突\r\n    - 链地址法\r\n\r\n- rehash\r\n    - 随着操作的不断进行，哈希表的键值对会逐渐的增多或减少，为了让负载因子维持在合理的一个范围内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或收缩。\r\n    - 扩展或者收缩哈希表通过rehash操作来完成, rehash操作分为三个操作\r\n        1. 为ht[1]哈希表分配空间，空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量\r\n            1. 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于h[0].used * 2的2**n(2的n次方幂)。比如当前为10,那么 扩展为2的6次方,即32 > 2*10 \r\n            2. 如果执行的的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2**n。比如当前为10,那么扩展为2的4次方，即16 > 10。\r\n        2. 将ht[0]中的所有键值对rehash到ht[1]上面: rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到h[1]哈希表的指定位置上。\r\n        3. 当ht[0]中的所有键值对都迁移到ht[1]之后(ht[0]此时是空表)，释放ht[0]，并将ht[1]设置为ht[0],并在ht[1]新创建一个空的哈希表，为下一次rehash做准备。\r\n    \r\n\r\n- 哈希表的扩展与收缩\r\n    - 两种情况下会执行扩展\r\n        1. 服务器没有执行BGSAVE或者BGREWRITEAOF,并且负载因子大于等于1。\r\n        2. 服务器目前正在执行BGSAVE或者BGREWAITEAOF，并且负载因为大于等于5。\r\n    - 执行扩展的第一种情况可以理解，负载因子大于一了，再不扩展可能哈希表性能会下降。那么第二种情况是为什么呢？这是因为当服务器执行BGSAVE或者BGREWAITEAOF命令时，redis需要创建当前服务器进程的子进程，而linux操作系统采用写时复制(copy-on-write)技术来优化子进程使用效率，所在在子进程存在期间，把负载因子调大为5，意为尽量不执行哈希表的扩展操作，这可以避免不必要的内存写入操作，最大限度节约内存。\r\n    - 当负载因子小于0.1, 程序自动执行收缩操作。\r\n    - 负载因子 = 哈希表已保存节点的数量 / 哈希表大小\r\n\r\n- 渐进式rehash\r\n    - 扩展或收缩哈希表不是一次性，集中式完成的，因为一个哈希表可能有上千万或者上亿个key,一次性的把这么多键从一个哈希表移动到另一个哈希表可能会使服务器在一段时间内停止服务。为了避免这个情况，服务器会分多次，渐进式的把ht[0]哈希表里面的键值对慢慢的rehash到ht[1]。\r\n    - 具体过程\r\n        1. 为ht[1]分配空间，这时字典同时拥有ht[0],ht[1]两个哈希表\r\n        2. 字典维持一个索引计数器变量rehashidx,并将它的值设置为0，表示rehash工作正式开始。\r\n        3. 在rehash期间，每次对字典执行添加，删除，查找或者更新操作，程序除了执行指定的操作外，还会顺带把rehashidx索引上的所有键值对rehash到ht[1],并将rehashidx属性的值增一。这样把rehash操作平摊到对字典的每个添加，删除，查找操作上。当ht[0]上所有键值对都rehash到ht[1]上，把rehashidx设为1，意为完成rehash工作。\r\n        4. 因为rehash是渐进的，所以要查找key是否存在，要到两个哈希表中分别查找。添加的元素一律直接添加到ht[1]里边。这一措施保证了ht[0]包含的键值对只会减少不会增加，并最终变为空表。','2022-02-05 23:20:54.988951','2023-12-23 15:54:02.595082','redis哈希表实现',51,13),(65,'Redis跳跃表实现','# 跳跃表\r\n\r\n> 跳跃表是一个插入，删除，查找时间复杂度都趋近与O(logn)时间复杂度的数据结构。这里来谈论一下redis跳跃表的实现\r\n\r\n### 简要\r\n1. 跳跃表示有序集合的底层实现之一\r\n2. redis跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表的信息(如表头节点，表尾节点，长度)，而zskiplistNode用于表示跳跃表节点。\r\n3. 每个跳跃表节点的层高都是1至32之间的随机数。\r\n4. 在同一个跳跃表中，多个节点可以包含相同的分数值，但每个节点的成员的的对象比如是唯一的。\r\n5. 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。\r\n6. \r\n---\r\n### 在有平衡树的情况下，为什么还需要跳跃表？\r\n\r\n我们都知道\r\n1. 链表的插入与删除操作时O(1)时间复杂度，而链表的查找或者定位一个元素却是O(n)时间复杂度。\r\n2. 有序数组的查找可以用二分查找，是O(logn)时间复杂度，要访问指定索引的元素，是O(1)时间复杂度，但是数组元素的插入与删除却是O(n)时间复杂度。\r\n\r\n**那么如何结合链表与数组的优点呢？**\r\n用二叉搜索树，二叉搜索树的中序遍历是有序的，并且增加，删除，查找操作的平均时间复杂度都是O(logn),但是二叉搜索树很容易退化为链表。\r\n\r\n**如何避免二叉搜索树退化为链表呢？**\r\n\r\n用平衡树，平衡树的的定义是任意一个节点的左右子树高度差的绝对值小于等于1。如果在增加或者删除操作时，左右子树高度差绝对值大于1，那么就进行平衡操作，树的自平衡过程比较复杂，实现起来麻烦，在高并发的情况下，加锁也会带来可观的开销。如AVL树需要LL、LR、RL、RR四种旋转操作保持平衡，红黑树则需要左旋、右旋和节点变色三种操作。\r\n\r\n**有没有简单点的、与自平衡树效率相近的实现方法呢？**\r\n\r\n用跳跃表。\r\n\r\n跳跃表通过在单链表上层再维持多个跨度更大的节点，来更快的查找访问节点。\r\n\r\n**完美跳跃表**\r\n\r\n参考数组的二分查找，我们很容易想到，在单链表上第二层每两个节点就维持一个新节点，第三层在第二层的基础上，再次每个两个节点就维持一个新节点，一次类推，这样很容易建立一个查找时间复杂度为O(logn)的跳跃表数据结构。这种严格按照二分法的思想建立的就是完美跳跃表。\r\n\r\n**完美跳跃表弊端**\r\n\r\n完美跳跃表在增加或者删除元素时，很容易破坏二分结构，会影响到查询效率，所以我们可以曲线救国，用另一种方法来达到类似二分的效果。\r\n\r\n### redis跳跃表实现\r\n\r\nredis使用类似抛硬币的方法来确定一个节点的上层是否用来建立辅助层，以及辅助层有多高。\r\n\r\n首先遍历第一层每一个节点，然后对每一个节点抛硬币，如果为正，则层高+1。然后遍历第二层的每一个节点，依然是为正则层高+1。\r\n\r\n很显然，当数据量大的时候，这种建立辅助层的效率将无限趋近与二分查找的O(logn)。\r\n\r\n当然，我上述的方法说的方式只是为了清晰的解释这种建立层高的方式。\r\n\r\nredis实际是根据幂次定律随机生成一个介于1和32之间的值作为层高。比如\r\n\r\n\r\n| 层高 | 概率 |\r\n| --- | --- |\r\n| 1 | 0.5**0 = 1 |\r\n| 2 | 0.5**1 = 0.5 |\r\n| 3 | 0.5**2 = 0.25|\r\n| 4 | 0.5**3 = 0.125|\r\n| 5 | 0.5**4 = 0.0625|\r\n| 6 | 0.5**5 = 0.03125|\r\n| ...... | ...... |\r\n\r\n这是和抛硬币一模一样的东西。\r\n\r\n\r\n### 查找操作\r\n\r\n\r\n从最高层开始比，节点小于要查找的值就一直往前，大于要查找的值就回退，并进入一下层。\r\n\r\n### 插入操作\r\n\r\n首先找到要插入的位置，还要记录下来查找的路径，然后把给插入的节点按照概率赋一个层高，然后改变节点指向(记录下来的路径里边拿到层节点的，然后层节点指向要插入的节点的相同层数的节点，然后把要插入的节点指定层数的下一个节点指向记录路径里边指定层数的下一个节点，和插入链表一样，不过要每一层都插入)。\r\n\r\n### 删除操作\r\n\r\n和插入类似，不再赘述。','2022-02-06 18:06:26.708085','2023-12-23 15:54:02.610730','Redis跳跃表实现',49,13),(66,'redis整数集合实现','# 整数集合\r\n\r\n> 整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为集合键的底层实现\r\n\r\n## 简要\r\n1. 整数集合是集合键的底层实现之一\r\n2. 整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型\r\n3. 升级操作为整数集合带来了操作上的灵活性，并且尽可能的节约内存\r\n4. 整数集合只支持升级操作，不支持降级操作\r\n\r\n---\r\n\r\n整数集合结构体\r\n\r\n    typedef struct intset{\r\n        \r\n        // 编码方式\r\n        uint32_t encoding;\r\n        \r\n        // 集合所包含的元素数量\r\n        uint32_t lenght;\r\n        \r\n        // 保存元素的数组\r\n        int8_t contents[];\r\n    \r\n    }intset\r\n    \r\n    \r\n### 升级\r\n\r\n\r\n当插入一个新元素插入到数组，并且新元素的类型(类型为int16或int32或int64)比整数集合的现有的所有元素的类型都长，就会触发升级，将数组类型变为新元素类型，并把之前数组内的所有元素类型都转换为新元素的类型。\r\n\r\n#### 好处\r\n\r\n1. 提高灵活性。可以随意的添加int16,int32,int64类型的整数到集合中，而不必担心出现类型错误\r\n2. 节约内存，只在新元素类型大于之前数组中的最大类型的时候才进行类型升级\r\n\r\n\r\n### 不支持数组降级','2022-02-06 18:06:58.218069','2023-12-23 15:54:02.618718','redis整数集合实现',43,13),(67,'redis压缩列表实现','# 压缩列表\r\n> 压缩列表(ziplist)s是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么是小整数值，要么就是长度比较短字符串，那么redis就会使用压缩列表来做列表键的底层实现。压缩列表压实哈希键的底层实现之一，当一个哈希键的每个键值对要么是小整数值，要么是长度比较短的字符串，redis就会使用压缩列表来做哈希键的底层实现\r\n\r\n## 简要\r\n1. 压缩列表是一种为节约内存而开发的顺序型数据结构\r\n2. 压缩列表诶用作列表键和哈希键的底层实现之一\r\n3. 压缩列表可以包含多个节点，每个节点都保存一个字节数组或者整数值\r\n4. 添加新节点到压缩列表，或者从压缩列表中删除节点，可能引发连锁更新操作，但是这种操作出现几率并不高\r\n5. 压缩列表从后向前遍历\r\n\r\n---\r\n\r\n压缩列表结构体和节点结构体\r\n\r\n\r\n        typedef struct ziplist{\r\n            \r\n            // 记录整个压缩列表占用的内存字节数: 在对压缩列表进行内存重分配或者计算zlend的位置时使用\r\n            uint32_t zlbytes; \r\n            \r\n            // 记录压缩列表表尾节点距离压缩列表的起始节点有多少字节: 通过整个偏移量，程序无序遍历整个压缩列表就可以确定表尾节点的指针\r\n            uint32_t zltail;\r\n            \r\n            // 记录压缩列表包含的节点数量，当整个属性的值小于uint16_max(65535)时，这个属性的值就是压缩列表的节点数量，当大于等于uint16_max时，需要遍历压缩列表\r\n            uint_16_t zllen;\r\n            \r\n            // 列表节点\r\n            entryX []ziplistNode;\r\n            \r\n            // 用于标记列表末端\r\n            uint8_t zlend;\r\n        }\r\n    \r\n        typedef struct ziplistNode{\r\n            // 前一个节点的长度，可以根据这个属性从后向前遍历。大小为1字节(长度小于254)或5字节(大于等于254)\r\n            previous_entry_length;\r\n            \r\n            // 保存节点内容的类型以及长度\r\n            encoding;\r\n            \r\n            // 节点保存的内容\r\n            content;\r\n        }\r\n    \r\n\r\n\r\n**压缩列表大约如下**\r\n\r\n| Col1 | Col2 | Col3 | Col4 | Col5 | Col6 | Col7 | Col8 |\r\n| --- | --- | --- | --- | --- | --- | --- | --- |\r\n| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend |\r\n\r\n\r\n### 连锁更新\r\n\r\n压缩列表的节点的previous_entry_length属性的大小是根据前一个节点的长度确定的。也就是前一个节点长度小于254就是1字节，而大于等于就是5字节。\r\n\r\n而压缩列表是可以插入或者删除的，所以当插入一个较大的元素，那么插入后，如果插入元素的后一个节点的previous_entry_length属性为1字节，不足以保存新插入节点的长度，就会更新后一个节点的previous_entry_length属性的大小为5字节，如果恰好后边也有连续的节点大小都在250-253(一字节保存254，更新为5字节刚好增加四个字节，而这个区间加上四个字节，都会使后边元素更新)，就会触发连锁更新。\r\n\r\n连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作(从第一个节点连续更新到最后一个)，而每次空间重分配的最坏时间复杂度为O(n)(全部元素都移动),所以连锁更新最坏时间复杂度为O(n**2)。\r\n\r\n尽管连锁更新时间复杂度很高，但是这种情况极少发生。\r\n\r\n就如上边所说，发生连锁更新的情况是很苛刻的。并且就算发生了，连锁更新的几点数量不多，也是绝不会影响性能的。','2022-02-06 18:07:26.593220','2023-12-23 15:54:02.614747','redis压缩列表实现',62,13),(68,'https原理','# https\r\n\r\n## 简要\r\n1. 明文  裸奔\r\n2. 对称   key唯一=明文\r\n3. 非对称  客户端到服务端安全，服务端到客户端不安全\r\n4. 对称+非对称  中间人问题\r\n5. 对称+非对称+CA数字证书\r\n\r\n---\r\n## 对称加密\r\n\r\n公钥加密，公钥解密\r\nf1(k, data) = x\r\nf2(k, x) = data\r\n\r\nk即为公钥\r\n\r\n服务端制定秘钥k,然后把k发送给客户端，客户端拿到k,用秘钥k对要发送的数据进行加密，然后传递给服务端，服务端再用秘钥k解密\r\n\r\n这个是有问题的。\r\n\r\n因为key也是要传输给客户端的，这个传输也是没有不加密，所以黑客很容易拿到这个key。比如黑客伪装客户端，获取到key，就可以对用户传输的数据进行解密\r\n\r\n**当然也可以服务端给每个用户都用不同的私钥，这样黑客就算伪装成客户端，拿到私钥，也解不开别人的。但是这样的话，服务端可能要存储和客户端数量一样多的私钥，这不太好，并且黑客也同样能拿到每一个客户端的公钥**\r\n\r\n## 非对称加密\r\n\r\n公钥加密,私钥解密\r\nf(p_k, data) = y\r\nf(s_k, y) = data\r\n\r\n私钥加密,公钥解密\r\nf(s_k, data) = y\r\nf(p_k, y) = data\r\n\r\n- 客户端向服务端发送数据\r\n\r\n服务端拥有公钥和私钥，客户端请求公钥，服务端把公钥发送给客户端，客户端用公钥对数据进行加密，服务端收到数据用私钥进行解密。这个时候，就算黑客知道公钥也没用，因为只有私钥可以解密数据，而服务端从来就没有传输过私钥，没人知道私钥是什么。\r\n\r\n- 服务端向客户端发送数据\r\n\r\n服务端用私钥进行数据加密，然后把数据发送给客户端，客户端用公钥进行解密。这是不行的，因为公钥是公开的，黑客很容易知道拿到公钥，拿到公钥就可以对服务端数据进行解密。\r\n\r\n**也就是说，非对称加密客户端向服务端发送数据是安全的的**\r\n\r\n## 对称加密+非对称加密\r\n\r\n结合对称加密和非对称加密。通过非对称加密交换秘钥，然后用这个秘钥通过对称加密传输数据。\r\n\r\n具体过程是这样的。\r\n\r\n服务端生成一个公钥，一个私钥。然后把公钥发送给客户端，客户端本地指定一个随机字符串，然后用公钥加密这个随机字符串，然后把加密后的随机字符串发送给服务端，服务端用私钥进行解密，获得客户端的随机字符串。这一过程是安全的，因为只有私钥才可以解密数据，而除了服务端没人知道私钥。因为随机字符串是客户端生成的，并加密后传输的。所以目前为止，只有客户端，服务端两方知道这个随机字符串。\r\n\r\n也就是说，可以把这个随机字符串当做秘钥，用对称加密来传输数据了。\r\n\r\n这看起来已经无懈可击了，其实还是有漏洞的。\r\n\r\n\r\n## 中间人攻击\r\n\r\n> 也就是黑客对用户来说，伪装成服务器，对服务器来说，伪装成客户端\r\n\r\n当客户端第一次向服务端请求公钥的时候，黑客拦截，黑客也有自己的公钥和私钥，黑客把自己的公钥给客户端。同时黑客也向真正的服务端请求公钥，服务端把公钥给黑客。\r\n\r\n然后真正的客户端收到黑客的公钥后，误以为是真正的服务端发送的公钥，就用这个公钥加密一个随机字符串，然后把加密后的字符串发送给黑客，黑客用自己的私钥对加密字符串进行解密，获得客户的随机字符串(也就是秘钥)。\r\n\r\n然后再用自己的公钥对这个随机字符串进行加密，传输给真正的服务器，服务器用自己的私钥进行解密，获得随机字符串。\r\n\r\n至此，客户端，黑客，服务端，都知道了秘钥。\r\n\r\n这时，真正的客户端和真正的服务端都以为天衣无缝开始传输数据。\r\n\r\n客户端把数据发送给黑客，黑客转发给服务端。\r\n服务端把数据发送给黑客，黑客转发给客户端。\r\n\r\n数据全被黑客看完了。\r\n\r\n## CA证书签名认证\r\n\r\n中间人攻击是因为黑客弄了个自己的pk,来糊弄人。\r\n\r\n那我们只要保证pk的绝对安全就可以了。\r\n\r\n这需要一个权威的认证机构,即证书颁发机构(CA, Certificate Authrity)\r\n\r\n1. 服务端依然有自己的pk,sk。但不是直接把这个pk发送给客户端，而是把pk通过非对称加密传给CA,CA通过f(csk, pk) == > license得到license。这个license里边包含了服务器的信息，包括域名等。\r\n2. 服务端把license发送给客户端，客户端通过写死到操作系统的cpk解密license,得到pk,然后就是非对称加密那一套，弄一个随机字符串，交换秘钥。\r\n\r\n\r\n假如这里仍然有中间人问题，比如一个黑客服务器自己弄个pk,sk，然后申请一个license,把这个license给客户端。这时客户端是可以校验license,一看域名不对，就会警告。\r\n\r\n以访问百度为例，百度也是有https保护的。\r\n\r\n    1：C--->S  发送请求，请求中携带了https支持的SSL的版本，对应的非对称算法，随机数num1\r\n    \r\n    2：S--->C 获得了请求中的内容之后，决定了要使用的SSL的版本，以及要使用的对称加密的算法，生成一个随机数num2，还有license\r\n    \r\n    3：C去认证license  只有认证成功才能进行之后的操作。\r\n    \r\n    4：认证成功后，C--->S 发送数据，发送的数据包含一个随机数num3，还有散列算法hash，将交互过程的第一和第二步一起hash（即hash（1,2））得到一个值xx\r\n    \r\n    5：S 端收到了hash值xx之后，进行验证，看xx的值是不是通过hash（1,2）得到的，如果是，说明客户端的身份没有问题，反之就有可能是黑客。认证成功之后，将随机数1,2,3经过一个算法生成一个随机数k\r\n    \r\n    6：S--->C  进行hash（1,2,4）得到zz，发送给客户端C\r\n    \r\n    7：C 也进行hash（1,2,4），看得到的是不是zz，如果是的话，说明服务端的身份也没有问题。没有问题之后，也将随机数1,2,3经过一个算法生成一个随机数k。而这个k和第5步的k是完全一样的。这个k是各自生成的，不在信道上传输，因此并不会泄露。\r\n\r\n## 总结\r\n\r\n对称 + 非对称 + CA证书','2022-02-07 16:42:14.577061','2023-12-23 15:54:02.622913','https原理',66,14),(69,'redis持久化之RDB','# RDB\r\n\r\n## 简要\r\n\r\n1. RDB文件保存和还原redis服务器所有数据库中的所有键值对数据\r\n2. save命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器\r\n3. bgsave命令由子进程执行保存操作，所在该命令不会阻塞服务器\r\n4. 服务器状态中保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行bgsave操作\r\n5. rdb文件是一个经过压缩的二进制文件，由多个部分组成\r\n6. 对于不同类型的键值对，rdb文件会使用不同的方式的保存他们。\r\n\r\n\r\n---\r\n### rdb文件创建和载入\r\n\r\n- 创建\r\n\r\nredis有两个命令可以用于生成rdb文件，\r\n\r\n1. save\r\n\r\nsave会阻塞服务器进程，直到rdb文件创建完毕为止，服务器进程阻塞期间，不能处理命令请求\r\n\r\n2. bgsave\r\n\r\nbgsave命令不会阻塞服务器进程，而是派生一个子进程，然后由子进程负责创建rdb文件\r\n\r\n- 载入\r\n\r\n因为aof持久化更新频率通常高于rdb。所以\r\n\r\n1. 服务器开启了aof持久化功能，那么服务器会优先使用aof文件来还原数据库\r\n2. 如果没开启，用rdb文件还原\r\n\r\n### 自动间隔保存\r\n\r\n默认情况下redis会有以下配置\r\n\r\n    save 900 1\r\n    save 300 10\r\n    save 60 10000\r\n    \r\n也就是\r\n\r\n900秒内至少对数据库进行1次修改\r\n300秒内至少对数据库进行10次修改\r\n60秒内至少对数据库进行10000次修改\r\n\r\n简单说就是对数据库操作越频繁，自动执行bgsave命令越频繁','2022-02-08 12:56:01.672674','2023-12-23 15:54:02.631545','redis持久化之RDB',72,13),(70,'redis持久化之AOF','# AOF(append only file)\r\n\r\n## 简要\r\n\r\n1. AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态\r\n2. AOF文件中的所有命令都以redis命令请求协议的格式保存\r\n3. 命令请求会先保存到AOF缓冲区里边，之后再定期写入并同步到AOF文件\r\n4. appendfsync选项的不同值对AOF持久化功能的安全性以及redis服务器的性能有很大的影响\r\n5. 服务器只要载入并重新执行保存的AOF文件中命令，就可以还原数据库本来的状态\r\n6. AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原来的AOF文件所保存的数据库状态一样，但是体积要更小\r\n7. AOF重写是有歧义的名字，它并没有对现有的AOF文件进行任何的读入，分析或者写入操作，而是直接读取数据库中的键值对来实现的。\r\n8. 在执行bgrewriteaof(aof文件重写)时，redis服务器会维护一个aof重写缓冲区，该缓冲区会在子进程创建新的aof文件期间，记录服务器执行的所有命令。当子进程完成创建aof文件的工作后，服务器会将重写缓冲区的所有内容追加到新aof文件末尾，使新旧两个aof文件所保存的数据库状态一致，最后服务器用新的aof文件替换旧的aof文件，aof重写操作完成。\r\n\r\n--- \r\n\r\n- 文件写入与同步\r\n\r\n当redis执行写命令，会首先将命令写入aof_buf缓冲区，然后调用flushappendonlyfile函数，考虑是否进行持久化。flushappendonlyfile行为由appendfsync决定\r\n\r\n三种方法进行持久化\r\n\r\n\r\n\r\n| appendfsync | flushappendonlyfile函数的行为 |\r\n| --- | --- |\r\n| always | 将aof_buf中内容写入到aof缓冲并持久化到aof文件 |\r\n| everysec | 将把aof_buf中的内容写入到aof缓冲，但是每秒持久化aof文件一次 |\r\n| no | aof_buf中文件写入到aof缓冲中，但是并不立即持久化，什么时候持久化由操作系统决定 |\r\n\r\n> 哪来的aof缓冲？现在操作系统为了提高文件写入效率，当用户调用write函数，将一些数据写入到文件时，操作系统会把写入数据保存在内存缓冲区中，等缓冲区满了或者超过了指定时限后再写入磁盘\r\n\r\n很明显的是，appendfsync的不同选项深深的影响着redis的效率和安全性\r\n\r\n也就是持久化越频繁，安全性越高，但是效率越低\r\n\r\nredis默认的appendfsync选项是everysec.\r\n\r\n\r\n- aof重写\r\n\r\naof持久化是通过保存被执行的命令来记录数据库状态的，所有随着时间流逝，aof文件中的内容会越来越多，可能会对redis服务器甚至宿主机造成影响。\r\n\r\n为了解决aof文件体积膨胀问题，redis提供了aof重写\r\n\r\naof重写不是对aof文件操作，而是读数据库，把数据库里边的数据用命令行的形式表示出来。\r\n\r\n比如\r\n\r\n    rpush list a b\r\n    rpush list c\r\n    rpush list d e\r\n    lpop list   // a\r\n\r\n为了记录整个list状态要四条命令，重写的话只需要一条，即\r\n\r\n    rpush list b c d e\r\n    \r\n- aof后台重写\r\n\r\n 重写会执行bgrewriteaof，在执行bgrewriteaof(aof文件重写)时，redis服务器会维护一个aof重写缓冲区，该缓冲区会在子进程创建新的aof文件期间，记录服务器执行的所有命令。当子进程完成创建aof文件的工作后，服务器会将重写缓冲区的所有内容追加到新aof文件末尾，使新旧两个aof文件所保存的数据库状态一致，最后服务器用新的aof文件替换旧的aof文件，aof重写操作完成。','2022-02-08 12:56:35.515477','2023-12-23 15:54:02.627525','redis持久化之AOF',72,13),(71,'Redis复制','## redis主从复制\r\n\r\n主从复制的作用主要包括:\r\n\r\n1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\r\n2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\r\n3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。\r\n4. 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。\r\n\r\n---\r\n\r\nredis可以通过slaveof命令或者设置配置文件中的slaveof选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为主服务器，而对主服务器进行复制的服务器则被称为从服务器。\r\n\r\n## 旧版复制功能的实现\r\n\r\nredis的主从复制功能分为同步和命令传播两个操作\r\n\r\n- 同步\r\n\r\n同步操作用于将服务器的数据库状态更新至主服务器当前所处的数据库状态\r\n\r\n1. 从服务器向主服务器发送sync命令\r\n2. 主服务器收到命令执行bgsave命令，在后台生成一个rdb文件，并使用一个缓冲区记录从现在到开始执行命令的所有写命令\r\n3. 当主服务器bgsave命令执行完毕，rdb文件发送给从服务器，从服务器载入rdb文件，将自己的数据库状态更新至主服务器执行bgsave命令时的数据库状态。\r\n4. 主服务器将记录在缓冲区的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。\r\n\r\n- 命令传播\r\n\r\n命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致时，让主从服务器的数据库重回一致状态。\r\n\r\n同步操作完毕后就是命令传播阶段\r\n\r\n1. 主服务器将自己接收到的所有写命令发送给从服务器，使从服务器达到和主服务器一样状态\r\n\r\n\r\n### 旧版复制功能弊端\r\n\r\n当从服务器和主服务器断开连接，并重新连接的时候，按理说只把断开连接后的命令发送给从服务器就行了，但是旧版复制会重新生成一个全量rdb文件，发送给从服务器，导致效率很低。\r\n\r\n## 新版复制功能的实现\r\n\r\n新版复制功能完善了旧版的弊端。新版复制使用psync代替sync。\r\n\r\npsync具有完整重同步和部分重同步功能\r\n\r\n1. 完整同步\r\n\r\n用于处理连接主服务器，主服务器生成全量rdb文件给从服务器\r\n\r\n2. 部分重同步\r\n\r\n解决了旧版复制断线重连效率低的问题。在从服务器重连上主服务器后，主服务器只发送从服务器断线后接收到写命令。\r\n\r\n### 部分重同步的实现\r\n\r\n部分重同步由三部分构成\r\n\r\n1. 主服务器的复制偏移量和从服务器的复制偏移量\r\n\r\n主服务器和从服务器都会维护一个自己的复制偏移量，比如当前主服务器a和从服务器b,c的复制偏移量都是1000,然后b服务器掉线了，b服务器掉线期间，主服务器a和从服务器c的复制偏移量增加为\r\n了1200。那么当b服务器上线，主服务器就知道b还有200复制偏移量没有传输，就传输过去。\r\n\r\n2. 主服务器的复制挤压缓冲区\r\n\r\n并不是不管从服务器掉线多久，只要连上主服务器就能进行部分重同步。\r\n\r\n因为主服务器有一个复制挤压缓冲区，主服务器进行命令传播时，不仅把写命令发送给从服务器，也会写入到复制挤压缓冲区里。\r\n\r\n只有从服务器的复制偏移量还在主服务器的复制挤压缓冲区里，才会执行部分重同步，否则执行完整重同步\r\n\r\n3. 服务器的运行ID\r\n\r\n每个服务器都有运行id,这个id唯一标识一个服务器。主服务器用这个运行id来判断从服务器是断连还是第一次连接。\r\n\r\n## 心跳检测\r\n\r\n命令传播阶段。从服务器以每秒一次的频率向主服务器发送命令\r\n\r\nREPLCONF ACK <replication_offset(复制偏移量)>\r\n\r\n这对于主从服务器作用有三\r\n1. 检测主从服务器网络连接状态\r\n\r\n如果主服务器超过一秒没收到从服务器的心跳检测的命令，就判定主从服务器连接出现故障\r\n\r\n2. 辅助实现min-slaves选项\r\n\r\n防止不安全情况下执行写命令\r\n\r\n当\r\n\r\nmin-slaves-to-write 3  // 从服务器数量少于三个\r\nmin-salves-max-lag 10  // 从服务器的延迟超过十秒\r\n\r\n满足上面任意一条，主服务器拒绝执行写命令\r\n\r\n3. 检测命令丢失\r\n\r\n心跳检测会发送复制偏移量，当命令丢失，主服务器会根据缺失的复制偏移量进行部分重同步。','2022-02-14 18:25:08.336363','2023-12-23 15:54:02.649082','Redis复制',69,13),(72,'redis哨兵','## redis高可用之哨兵(Sentinel)\r\n\r\n> Sentinel(哨岗，哨兵)是Redis高可用性的解决方案: 由一个或者多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及主服务器下的从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务继续处理命令请求。\r\n\r\n每个sentinel拥有一个masters字典，字典中记录了所有被哨兵监视的主服务器信息\r\n\r\n字典key为主服务器名字\r\n字典值为sentinel.c/sentinelRedisInstance结构，这个结构可以是主服务器，从服务器或者哨兵\r\n\r\nsentinelRedisInstance有个salves属性，salves是一个从服务器字典\r\n\r\n字典key为从服务器ip:port\r\n字典值为从服务器sentinelRedisInstance实例\r\n\r\n- 获取主服务器信息\r\n\r\n当sentinel初始化时候会从配置文件读取主服务器的信息，和主服务器建立命令连接和订阅连接，哨兵每十秒向主服务器发送一次info命令，并通过主服务器对info命令的回复来获取主服务器信息，主要两方面\r\n\r\n> 为什么需要同时建立命令连接和订阅连接？因为redis发布与订阅功能中，服务器不会将被发送的信息保存在redis服务器里，也就是如果发送一次，客户端断线没收到，这个信息就丢了。因此，为了不丢失__sentinel__: hello频道的信息，必须专门用一个订阅连接来接收频道消息。同时，sentinel还需要向主服务器发送命令，以此来通信，所有还需要建立命令连接。\r\n\r\n1. 主服务器本身的信息\r\n2. 主服务器的下属从服务器的信息\r\n\r\n- 获取从服务器信息\r\n\r\n当哨兵通过主服务器信息对info命令的回复，来获得从服务器的信息。然后会创建连接向从服务器的命令连接和订阅连接。同样，哨兵也会每秒向从服务器发送info来获得从服务器的信息。\r\n\r\n\r\n- 向主服务器和从服务器发送信息\r\n\r\n默认情况下，Sentinel会以每两秒一次的频率，通过命令向连接向所有被监视的主服务器和从服务器发送命令，命令包括\r\n\r\n1. 自身的信息，ip地址，端口号，运行id,配置纪元\r\n2. 被监视的主服务器的信息。如果监视的是主服务器，那么就是主服务器的信息，如果监视的是从服务器，那么就是从服务器的主服务器的信息\r\n\r\n- 接收来自主服务器和从服务器的频道信息\r\n\r\nSentinel可以通过命令连接向服务器的__sentinel__: hello 频道发送信息，也可以通过此频道接收信息。\r\n\r\n当一个sentinel向服务器频道发送信息，所有和这个服务器建立订阅连接的哨兵都会收到信息。\r\n\r\n- 创建连接向其他sentinel的命令连接\r\n\r\n一个哨兵向服务器的频道发送信息，其他所有订阅此频道的哨兵都会收到信息，并通过信息，发现新的哨兵，并和新的哨兵建立命令连接。\r\n\r\n### 检测主观下线状态\r\n\r\n哨兵会以每秒一次的频率向所有与他创建的实例(包括主服务器，从服务器，其他sentinel)发送ping命令，并通过实例的回复来判断实例是否在线。\r\n\r\n有效的回复: 实例返回+pong, -loading, -masterdown三种回复中的一种。\r\n无效的回复: 实例返回除+pong, -loadomg. -masterdown三种回复外的其他回复或者指定时限内没有返回任何回复\r\n\r\n当哨兵发现一个主服务器疑似下线，就会向其他哨兵发送请求，询问看他们是否也认为主服务器进入了下线状态，当认为主服务器已经进入下线状态的Sentinel的数量超过sentinel配置文件中的quorum参数的值，那么当前哨兵就会认为主服务进入客观下线状态。\r\n\r\n### 选举领头sentinel\r\n\r\n当一个主服务器被判断为客观下线时，监视这个下线服务器的主服务器的各个sentinel会进行协商，选举出一个领头sentinel。领头sentinel对下线服务器执行主服务器的故障转移。\r\n\r\n1. 所有在线的监视主服务的哨兵都有可能称为领头sentinel\r\n2. 每次进行领头哨兵选举后，不论选举是否成功，所有sentinel的配置纪元的值都会自增一次\r\n3. 在一个配置纪元里，所有哨兵都有一次将某个sentinel设置为局部领头sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。\r\n4. 源哨兵会向其他哨兵发送命令，要求将自己设置为局部领头哨兵，一旦其他一个哨兵将一个哨兵设置为局部领头哨兵，就会拒绝其他哨兵的设置请求\r\n5. 哨兵设置局部哨兵的规则是先到先得，也就是最先向目标哨兵发送命令的源哨兵会被设置为局部领头哨兵\r\n6. 如果某个哨兵每半数以上的哨兵设置为局部领头哨兵，那么他就会成为领头哨兵。比如10个哨兵，那么大于等于6个哨兵设置局部领头哨兵为同一个哨兵，那么这个哨兵就是领头哨兵\r\n7. 在一个配置纪元里，一次选举需要半数以上支持才会选出一个领头哨兵，所以也可能一次选举一个领头哨兵都没选出来，那么会进行下一次选举。\r\n\r\n### 故障转移\r\n\r\n领头哨兵选出后，就会对已下线的主服务器执行故障转移操作，分三个步骤\r\n\r\n1. 从下线主服务器属下的所有从服务器中挑选一个从服务器，将其转换为主服务器\r\n2. 让已下线主服务下的从服务器改为复制新的主服务器\r\n3. 将已下线主服务器设置为新的主服务器的从服务器，当整个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。\r\n\r\n> 新的主服务器是怎样挑选出来的？要挑选在线的，五秒之内和领头哨兵进行过通信的，优先级高的，复制偏移量最大的，运行ID最小的。\r\n\r\n### 修改从服务器的复制目标\r\n\r\n当新的主服务器出现后，领头sentinel下一步要做的就是，让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作可以通过向从服务器发送slaveof命令来显示\r\n\r\n### 将旧的主服务器变为从服务器\r\n\r\n故障转移的最后要做的是，将已下线的主服务器设置为新的主服务器的从服务器。','2022-02-14 18:25:28.253219','2023-12-23 15:54:02.645000','redis哨兵',87,13),(73,'redis集群基础','## 集群\r\n\r\n> redis集群是redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。\r\n\r\n---\r\n\r\n### 节点\r\n\r\n一个redis集群通常由多个节点组成，每个节点都是一个redis服务器。在刚开始的时候，节点之间是独立的，要组建一个真正可用的集群需要将节点连接起来，构成一个集群。\r\n\r\n连接节点的命令是\r\n\r\n    cluster meet <ip> <port>\r\n\r\n向一个节点node发送cluster meet命令，可以让node节点与ip和port所指定的几点进行握手，当握手成功时，node节点就会将ip和port所指定的node节点添加到当前所在集群中。\r\n\r\n### 启动节点\r\n\r\n一个节点就是一个运行在集群模式下的redis服务器，redis服务器在启动时会根据cluster-enbled配置选项是否为yes来决定是否开启服务器的集群模式。\r\n\r\n### 集群数据机构\r\n\r\n- clusterNode\r\n\r\n每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点都创建一个clusterNode结构，以此来记录其他节点的状态。\r\n\r\nclusterNode结构保存了一个节点的当前状态，比如节点的创建时间，节点的名字，节点的当前纪元，节点的IP地址和端口号等。\r\n\r\n    \r\n    struct clusterNode {\r\n        mstime_t ctime; // 创建节点的时间\r\n        int flags;  // 节点标识，来判断节点是主节点还是从节点以及节点目前所处的状态\r\n        uint64_t configEpoch; // 节点当前的配置纪元，用于实现故障转移\r\n        int port; // 节点的端口号\r\n        unsigned char slots[16384/8] // 16384位大小(2kb)的二进制数组，是1则代表本节点处理这个槽，0代表本节点不处理这个槽\r\n        int numsolts;  // 记录节点负责处理的槽数量，也即使slots数组中值为1的数量\r\n        ....\r\n        ...\r\n        \r\n    }\r\n\r\n- clusterStatus\r\n\r\n每个节点都会使用一个clusterStatus结构，这个结构记录了在当前节点的视角下，集群所处的状态，例如集群是在线还是下线，集群中包含的节点，集群当前的配置纪元等。\r\n\r\n    type struct clusterStatus{\r\n        clusterNode *myself;  // 指向当前节点的指针\r\n        \r\n        uint64_t currentEpoch; // 集群目前的配置纪元\r\n        \r\n        int status; // 集群目前的状态，是在线还是下线\r\n        \r\n        int size; // 集群中至少处理了一个槽的节点的数量\r\n        \r\n        dict *nodes; // 集群节点名单，保存了目前集群下的所有其他节点的信息。key为节点名，val为一个clusterNode结构\r\n        \r\n        clusterNode *slots[16384];\r\n        ...\r\n        ..\r\n        \r\n    }\r\n\r\n### 槽指派\r\n\r\nRedis集群通过分片的方式保存数据库中的键值对: 集群中的整个数据库被分为16384个槽,数据库中的每个键都属于这16384个槽中的其中一个，集群中的每个节点可以处理0个或者16384个槽。\r\n\r\n当数据库中的所槽都有节点处理，集群处于上线状态；相反，如果数据库中有任何一个槽没有处理，那么集群处于下线状态。\r\n\r\n把槽指派给节点的命令是\r\n\r\n    cluster addslots 0 1 2 3 4 ... 5000  // 把槽0-5000(前闭后闭)指派给当前节点\r\n\r\n或者\r\n\r\n    cluster addslots 5001 5002 // 把槽5001,5002指派给当前节点\r\n    \r\n### 记录节点的槽指派信息\r\n\r\nclusterStatus结构中的slots数组记录了集群中所有16384个槽的指派信息。\r\n\r\nslots数组包含16384项，每个数组项都是一个指向clusterNode结构的指针。\r\n\r\n如果slots[i]指向null,表示槽i尚未指派给任何节点\r\n\r\n如果slots[i]指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点。\r\n\r\n\r\n### 在集群中执行命令\r\n\r\n在对数据库中的16384个槽都进行了指派后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。\r\n\r\n当客户端向任意一个节点发送与数据库键有关的命令时，接收命令的节点就会计算出命令要处理的数据库键数据哪个槽，并检查这个槽是否指派给了自己。\r\n\r\n- 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。\r\n- 如果键所在的槽没有指派给当前节点，就从clusterStatus.slots数组中查看槽所在的索引指向的节点，并向客户端返回一个MOVEN错误，把节点地址返回给客户端，指引客户端转向正确的节点，并再次发送想要执行的命令。\r\n\r\n### 计算键属于哪个槽\r\n\r\n节点使用以下算法计算给定键属于哪个槽\r\n\r\n    def slot_number(key):\r\n        return CRC16(key) & 16383\r\n        \r\n### 判断槽是否由当前节点负责处理\r\n\r\n根据键计算出槽i,如果clusterState.slots[i]等于slusterState.myself,说明槽由当前节点负责。\r\n根据键计算出槽i,如果clusterState.slots[i]不等于slusterState.myself,说明槽不由当前节点负责，并把正确的节点信息通过MOVEN错误返回给客户端。\r\n\r\n### 节点数据库的实现\r\n\r\n节点和单机数据库在数据库方面的区别是，节点只能用0号数据库。\r\n\r\n一个节点可能需要处理很多个槽，那么节点内部如何处理键和不同槽直接的关系呢？\r\n\r\n在clusterState结构中有个slots_to_keys跳跃表来保存键和槽的关系，分值为槽，节点保存的是数据库键。\r\n\r\n### 重新分片\r\n\r\nredis集群的重新分片操作可以将任意数量的已经指派给某个节点的槽改为指派给另外一个节点。\r\n\r\n当客户端向一个节点发送键命令，而这个键所在的槽正在迁移的话，如果这个键还在当前节点的槽中，就直接处理。如果已经迁移到另一个节点了，就由另一个节点处理。','2022-02-14 18:26:15.629054','2023-12-23 15:54:02.639827','redis集群基础',83,13),(74,'redis集群-复制与故障转移','## 复制与故障转移\r\n\r\n> redis集群中的节点分为主节点和从节点，主节点用于处理槽，从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。\r\n\r\n### 设置从节点\r\n\r\n向一个节点发送命令:\r\n\r\n    cluster replicate <node_id>\r\n\r\n可以让接收命令的节点称为node_id所指定节点的从节点，并开始对主节点开始复制\r\n\r\n### 故障检测\r\n\r\n集群中的每个节点都会定期的向集群中的其他节点发送ping消息，以此来检测对方是否在线，如果接收ping消息的节点没有在规定的时间内，向发送ping消息的节点返回pong消息，那么发送ping消息的节点就会把接收ping消息的节点标记为疑似下线。\r\n\r\n并且把这个节点疑似下线的消息传播向集群中的其他节点。并把这个节点的下线报告添加到自己的ClusterNode结构的fail_reports链表里:\r\n\r\n    struct clusterNode {\r\n        // 一个链表，记录了所有其他节点对该几点的下线报告\r\n        list *fail_reports;\r\n        ...\r\n        ..\r\n    }\r\n    \r\n当一个集群里，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线。\r\n\r\n### 故障转移\r\n\r\n当一个从节点发现自己正在复制的主节点已进入下线状态，从节点将开始对下线的主节点进行故障转移操作。\r\n\r\n1. 复制下线主节点的所有从节点里边，会有一个从节点被选中。\r\n2. 被选中的从节点会执行slaveof no one 命令，成为新的主几点\r\n3. 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全被指派给自己\r\n4. 新的主节点向集群中广播一条pong消息，这个pong消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽\r\n5. 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。\r\n\r\n### 选举新的主节点。\r\n\r\n新的节点是通过其他集群中其他主节点的选举产生的:\r\n\r\n1. 集群的配置纪元是一个自增计数器，它的初始值为0\r\n2. 当集群里的某个节点开始一次故障转移操作时，集群的配置纪元+1\r\n3. 对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票\r\n4. 当从节点发现自己正在复制的主节点下线，会广播clustermsg_type_falilover_auth_request消息，要求所有收到这个消息的主节点向这个从节点投票。\r\n5. 当一个从节点收到的的投票数大于等于N/2+1，那么这个从节点将变为主节点。\r\n6. 如果一个配置纪元内没有节点能够收到足够多的支持票，那么集群进入新的配置纪元，并再次进行选举，直到选出新的主节点。\r\n\r\n> 领头哨兵和集群主节点的选举，都是基于raft算法。','2022-02-14 18:26:54.513396','2023-12-23 15:54:02.635766','redis集群-复制与故障转移',122,13),(75,'redis分布式锁的实现','> 一年多没更新了，浅浅更新一下\r\n\r\n### 最简单的\r\n\r\n    SETNX key 1\r\n要获取锁，使用setnx命令，setnx意为如果不存在就设置，设置成功就返回1，\r\n设置失败就返回0\r\n\r\n问题：如果一个进程拿到锁后，进程挂掉了，会产生死锁，其他进程再也拿不到这个锁了。\r\n\r\n### 解决上述问题\r\n\r\n    setnx key 1 \r\n    expire key 10 // 10s后自动过期\r\n\r\n给锁加一个超时时间，十秒后自动过期，当拿到锁的进程挂掉情况下，也会释放锁，避免死锁。\r\n\r\n- 这抛出了另外三个问题\r\n  1. 锁过期时间多久合理？短的话进程还没执行完就给释放了，长的话可能导致加锁进程已经早早挂掉了，其他进程要阻塞相当长的一个锁的过期时间\r\n  2. 两条命令不能保证原子性，即第一条成功了，第二条失败了，那这个方法就失效了。\r\n  3. A进程拿到锁后执行时间超过了过期时间，这时候锁自动过期了，然后B进程拿到了锁，这时候A业务逻辑执行完了，释放了锁，把B的拿到锁释放了(导致并发问题)。\r\n\r\n\r\n\r\n### 解决原子性问题\r\n\r\nRedis 2.6.12解决了setnx和expire两条命令的原子性问题    \r\n即\r\n    \r\n    SET key 1 EX 10 NX // 如果key不存在就设置为1，并把过期时间设置为10s\r\n\r\n同时我们不固定key对应的val的值，而是每一个进程拥有自己独一无二的val,当释放锁的时候，判断是否是自己上的锁，来解决释放别人锁的问题\r\n即 \r\n\r\n上锁\r\n\r\n    SET key uniq_val EX 10 NX // 如果key不存在就设置值为uniq_val(当时时间戳，uuid等都可以，只要保证唯一性)，并把过期时间设置为10s\r\n\r\n释放锁\r\n\r\n    if redis.Get(key) == unia_val{\r\n        redis.del(key)\r\n    }\r\n\r\n问题: 很显然，释放锁的过程不是原子性的，极端情况下，依然会出现并发问题    \r\n即\r\n\r\n    1. 客户端 1 执行 GET，判断锁是自己的\r\n    2. 客户端 1 执行 GET 结束后，这个锁刚好超时自动释放\r\n    3. 此时，恰好客户端 2 又获取到了这个锁\r\n    4. 之后，客户端 1 在执行 DEL 时，释放的却是客户端 2 的锁\r\n\r\n使用lua脚本结局释放锁的一致性问题，redis执行请求是单线程，当redis执行一个lua脚本时候是能够保证lua脚本里的所以命令具有原子性的。\r\n\r\n    // 判断锁是自己的，才释放\r\n    if redis.call(\"GET\",KEYS[1]) == ARGV[1]\r\n    then\r\n        return redis.call(\"DEL\",KEYS[1])\r\n    else\r\n        return 0\r\n    end\r\n\r\n### 最后一个问题\r\n过期时间如何设置更加合理？\r\n\r\n一个既有的方案是：加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。','2023-04-17 17:13:37.308987','2023-12-23 15:54:02.653380','如何使用redis时限分布式锁',52,19),(76,'Go垃圾回收','## go垃圾回收\r\n\r\n### 前期，标记清除法  stw问题\r\n\r\n1.  从根节点递归的遍历所有可达节点，并标记这些节点\r\n2.  清除所有标记的节点\r\n\r\n在标记和清除阶段，程序是不能运行的，也就是stw问题。\r\n\r\n### 三色标记法 减弱了stw问题，但是也有stw问题\r\n\r\n三色标记法，顾名思义，把内存分为三个颜色\r\n\r\n*   黑色，已经标记的活跃对象，并且所有引用已经扫描过，不需要回收。会放到黑色列表\r\n*   灰色，已经标记，至少有一个引用还未被扫描，不需要回收。会放到灰色列表\r\n*   白色，未遍历到的对象。\r\n\r\n1.  从根节点出发，把根节点关联的节点标记为灰色(不递归)，只标记和根节点直接相连的。\r\n2.  遍历灰色列表，把和灰色节点直接相连的标记为灰色，并把当前灰色节点标记为黑色。\r\n3.  以此类推，直到只剩下黑色和白色两种颜色，此时把白色的回收掉。\r\n\r\n不stw会发生什么？\r\n\r\n会发生把正在使用的内存回收掉\r\n\r\n比如一个在标记的过程中，一个黑色对象引用到了一个白色对象，由于我们不会再次遍历黑色对象，会导致这个白色对象被回收掉。\r\n\r\n如何解决这个问题?\r\n\r\n### 强弱三色不变式\r\n\r\n1.  强三色不变式  即 不允许黑色对象引用白色对象\r\n2.  弱三色不变式  即 黑色对象仍然可以应用白色对象，只是这个白色对应一定要同时被其他的灰色对象所引用\r\n\r\n只要满足上述其一，就可以保证引用的对象不被错误的回收\r\n\r\n### 插入屏障\r\n\r\n对象被引用时候触发的机制\r\n\r\n具体操作: 垃圾回收的过程中，如果黑色对象引用了一个新的对象，把这个新的对象置为灰色  满足强三色不变式\r\n\r\n插入屏障需要做很多判断操作，有一定的内存损耗，如果在栈中使用会对程序的运行造成影响。所以栈内存不触发插入屏障。\r\n\r\n那么栈空间如何保证被使用的内存不被错误的回收呢？当一轮扫描完，准备回收白色对象的时候，再次扫描一遍栈空间，这次加入stw,防止外界干扰。\r\n\r\n不足：栈空间依然需要stw。\r\n\r\n### 删除屏障\r\n\r\n对象被删除的时候触发的机制\r\n\r\n具体操作: 如果删除了对一个对象的引用，那么把这个对象标记为灰色。\r\n这么做虽然可能导致已经不再使用的对象依然保留，但是却可能潜在的保护了下游正在使用的对象。比如黑色对象引用了白色，这个白色同时也被一个灰色对象所引用，那么如果灰色对象删除对这个白色对象的引用的时候，把这个白色对象置为灰色，来保护这个对象(因为这个对象正在被黑色所引用)。而如果这个白色对象确实是没有被黑色对象所引用，也无妨，因为会在下一轮垃圾回收的时候，真正的把它回收掉。\r\n\r\n小case: 依然会有一个小的stw,来做快照，在下次垃圾回收的时候做对比。\r\n不足：回收精度比较低，一个对象即使被删除，依然会多存活一轮垃圾回收的时间 。\r\n栈和堆的区别。\r\n\r\n堆，空间大，提供内存多\r\n栈，空间小，对性能要求更高，提供内存和函数调用\r\n\r\n### go 1.8 三色标记法 + 混合写屏障机制\r\n\r\n具体操作：\r\n1. gc开始将栈上的对象全部扫描并标记为黑丝(之后不再进行第二次扫描，无须stw)。\r\n2. gc期间,任何在栈上创建的新对象，均为黑色(类似插入写屏障的特点)。\r\n3. 一个对象被取消引用，那么把这个对象标记为灰色(删除写屏障的特点)。\r\n4. 被添加的对象标记为灰色(插入写屏障)。\r\n\r\n满足： 变形的弱三色不变式(结合插入删除写屏障两者的有点。)','2023-07-29 13:01:32.647039','2023-12-23 15:54:02.657594','Go语言垃圾回收机制',22,18);
/*!40000 ALTER TABLE `mainapp_post` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mainapp_post_tags`
--

DROP TABLE IF EXISTS `mainapp_post_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mainapp_post_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `post_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `mainapp_post_tags_post_id_tag_id_d0b64de5_uniq` (`post_id`,`tag_id`),
  KEY `mainapp_post_tags_tag_id_2977ec43_fk_mainapp_tag_id` (`tag_id`),
  CONSTRAINT `mainapp_post_tags_post_id_c17f14a5_fk_mainapp_post_id` FOREIGN KEY (`post_id`) REFERENCES `mainapp_post` (`id`),
  CONSTRAINT `mainapp_post_tags_tag_id_2977ec43_fk_mainapp_tag_id` FOREIGN KEY (`tag_id`) REFERENCES `mainapp_tag` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=97 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mainapp_post_tags`
--

LOCK TABLES `mainapp_post_tags` WRITE;
/*!40000 ALTER TABLE `mainapp_post_tags` DISABLE KEYS */;
INSERT INTO `mainapp_post_tags` VALUES (3,6,3),(4,7,11),(5,8,14),(6,9,14),(7,10,28),(8,11,6),(9,12,5),(10,13,4),(12,15,7),(11,15,8),(13,16,9),(14,17,10),(15,18,12),(16,19,12),(17,20,12),(18,21,13),(19,22,13),(20,23,15),(21,24,18),(22,25,23),(23,26,16),(24,27,19),(25,28,20),(27,29,21),(26,29,29),(29,30,21),(28,30,26),(31,31,21),(30,31,26),(33,32,22),(32,32,24),(34,34,25),(35,35,25),(36,36,24),(37,36,25),(38,37,28),(39,38,30),(40,39,29),(41,40,29),(42,41,12),(43,42,12),(44,43,31),(45,44,32),(52,49,23),(53,50,23),(55,51,34),(56,51,35),(57,52,29),(58,53,36),(59,54,26),(60,55,18),(61,56,37),(62,57,11),(63,57,28),(64,58,28),(66,59,30),(65,59,38),(67,60,37),(68,60,39),(69,61,40),(71,62,21),(70,62,26),(73,63,21),(72,63,26),(75,64,21),(74,64,26),(77,65,21),(76,65,26),(79,66,21),(78,66,26),(81,67,21),(80,67,26),(82,68,41),(83,69,26),(84,70,26),(86,71,21),(85,71,26),(88,72,21),(87,72,26),(90,73,21),(89,73,26),(92,74,21),(91,74,26),(93,75,26),(95,75,42),(94,75,43),(96,76,37);
/*!40000 ALTER TABLE `mainapp_post_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mainapp_tag`
--

DROP TABLE IF EXISTS `mainapp_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mainapp_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=44 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mainapp_tag`
--

LOCK TABLES `mainapp_tag` WRITE;
/*!40000 ALTER TABLE `mainapp_tag` DISABLE KEYS */;
INSERT INTO `mainapp_tag` VALUES (3,'闭包'),(4,'nginx'),(5,'部署blog'),(6,'docker'),(7,'java-继承'),(8,'向上转型，向下转型'),(9,'java接口'),(10,'java_abstract'),(11,'装饰器'),(12,'django'),(13,'Scrapy'),(14,'Python特殊方法'),(15,'二分查找'),(16,'java集合'),(17,'python面向对象'),(18,'排序'),(19,'javascript语法'),(20,'Vue'),(21,'数据库'),(22,'三次握手，四次挥手'),(23,'二叉树'),(24,'TCP'),(25,'进程'),(26,'redis'),(27,'单例模式'),(28,'python语法'),(29,'mysql'),(30,'I/O模型'),(31,'树'),(32,'贪心算法'),(33,'想法'),(34,'哈希表'),(35,'位运算'),(36,'LRU缓存机制'),(37,'Golang'),(38,'I/O多路复用'),(39,'go反射'),(40,'协程'),(41,'HTTPS'),(42,'微服务'),(43,'分布式');
/*!40000 ALTER TABLE `mainapp_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mainapp_text_signature`
--

DROP TABLE IF EXISTS `mainapp_text_signature`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mainapp_text_signature` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `text` varchar(100) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mainapp_text_signature`
--

LOCK TABLES `mainapp_text_signature` WRITE;
/*!40000 ALTER TABLE `mainapp_text_signature` DISABLE KEYS */;
INSERT INTO `mainapp_text_signature` VALUES (1,'医治不死病，佛渡有缘人','2021-03-11 12:31:05.106897'),(2,'好好学习','2021-03-11 14:38:52.026604'),(3,'AiRJun','2021-03-11 22:40:07.479863'),(4,'贪财好色，一身正气。','2021-04-15 22:08:08.978764'),(5,'如果无产阶级不能发出自己的声音，他们就会被社会遗忘。','2021-04-19 23:59:51.445500'),(6,'如果你和我一样热爱生活，不羁自由，那你务必来找我，我请你喝酒。','2021-05-28 20:17:00.271362'),(7,'什么是人？欲望满身。','2021-06-25 15:39:56.963647'),(8,'如果无产阶级不能发出自己的声音，他们就会被社会遗忘。','2021-10-28 16:50:16.600367'),(9,'最近在做的事情: 编程，英语，健身','2023-07-29 13:03:21.428411'),(10,'防民之口，甚于防川','2023-10-25 17:19:51.923747');
/*!40000 ALTER TABLE `mainapp_text_signature` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-12-23 15:54:11
